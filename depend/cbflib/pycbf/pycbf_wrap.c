/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.40
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Python.h has to appear first */
#include <Python.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

/* Add PyObject_Del for old Pythons */
#if PY_VERSION_HEX < 0x01060000
# define PyObject_Del(op) PyMem_DEL((op))
#endif
#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *self, PyObject *func)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyInstanceMethod_New(func);
#else
  return NULL;
#endif
}

#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif


/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(ptr, type, flags)
#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule()
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, (char *) msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, (char*) name, obj);
  Py_DECREF(obj);                            
}

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN int
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    register Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      register int i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData* data)
{
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
} SwigPyObject;

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", name, v);
  if (v->next) {
#ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
#else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
#endif
#if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
#else
    PyString_ConcatAndDel(&repr,nrep);
#endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char *str;
#ifdef METH_NOARGS
  PyObject *repr = SwigPyObject_repr(v);
#else
  PyObject *repr = SwigPyObject_repr(v, NULL);
#endif
  if (repr) {
    str = SWIG_Python_str_AsChar(repr); 
    fputs(str, fp);
    SWIG_Python_str_DelForPy3(str);
    Py_DECREF(repr);
    return 0; 
  } else {
    return 1; 
  }
}

SWIGRUNTIME PyObject *
SwigPyObject_str(SwigPyObject *v)
{
  char result[SWIG_BUFFER_SIZE];
  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
    SWIG_Python_str_FromChar(result) : 0;
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) )
    res = Py_True;
  else
    res = Py_False;
  Py_INCREF(res);
  return res;  
}


SWIGRUNTIME PyTypeObject* _PySwigObject_type(void);

SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigObject_type();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;
      if (data->delargs) {
	/* we need to create a temporary object to carry the destroy operation */
	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
	res = SWIG_Python_CallFunctor(destroy, tmp);
	Py_DECREF(tmp);
      } else {
	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
	PyObject *mself = PyCFunction_GET_SELF(destroy);
	res = ((*meth)(mself, v));
      }
      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#else
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"aquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
_PySwigObject_type(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
  
  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;  
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp
      = {
	/* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
	PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else    
	PyObject_HEAD_INIT(NULL)
	0,				    /* ob_size */
#endif
	(char *)"SwigPyObject",		    /* tp_name */
	sizeof(SwigPyObject),		    /* tp_basicsize */
	0,			            /* tp_itemsize */
	(destructor)SwigPyObject_dealloc,   /* tp_dealloc */
	(printfunc)SwigPyObject_print,	    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
	(getattrfunc)SwigPyObject_getattr,  /* tp_getattr */ 
#else
	(getattrfunc)0,			    /* tp_getattr */ 
#endif
	(setattrfunc)0,			    /* tp_setattr */ 
#if PY_VERSION_HEX >= 0x03000000
    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
	(cmpfunc)SwigPyObject_compare,	    /* tp_compare */
#endif
	(reprfunc)SwigPyObject_repr,	    /* tp_repr */    
	&SwigPyObject_as_number,	    /* tp_as_number */
	0,				    /* tp_as_sequence */
	0,				    /* tp_as_mapping */
	(hashfunc)0,			    /* tp_hash */
	(ternaryfunc)0,			    /* tp_call */
	(reprfunc)SwigPyObject_str,	    /* tp_str */
	PyObject_GenericGetAttr,            /* tp_getattro */
	0,				    /* tp_setattro */
	0,		                    /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
	swigobject_doc, 	            /* tp_doc */        
	0,                                  /* tp_traverse */
	0,                                  /* tp_clear */
	(richcmpfunc)SwigPyObject_richcompare,           /* tp_richcompare */
	0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
	0,                                  /* tp_iter */
	0,                                  /* tp_iternext */
	swigobject_methods,		    /* tp_methods */ 
	0,			            /* tp_members */
	0,				    /* tp_getset */	    	
	0,			            /* tp_base */	        
	0,				    /* tp_dict */	    	
	0,				    /* tp_descr_get */  	
	0,				    /* tp_descr_set */  	
	0,				    /* tp_dictoffset */ 	
	0,				    /* tp_init */	    	
	0,				    /* tp_alloc */	    	
	0,			            /* tp_new */	    	
	0,	                            /* tp_free */	   
	0,                                  /* tp_is_gc */  
	0,				    /* tp_bases */   
	0,				    /* tp_mro */
	0,				    /* tp_cache */   
	0,				    /* tp_subclasses */
	0,				    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
	0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
	0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
    swigpyobject_type = tmp;
    /* for Python 3 we already assigned ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    swigpyobject_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* _PySwigPacked_type(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigPacked_type();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == _PySwigPacked_type()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
_PySwigPacked_type(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;  
  if (!type_init) {
    const PyTypeObject tmp
      = {
    /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX>=0x03000000
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
	PyObject_HEAD_INIT(NULL)
    0,				    /* ob_size */	
#endif
	(char *)"SwigPyPacked",		    /* tp_name */	
	sizeof(SwigPyPacked),		    /* tp_basicsize */	
	0,				    /* tp_itemsize */	
	(destructor)SwigPyPacked_dealloc,   /* tp_dealloc */	
	(printfunc)SwigPyPacked_print,	    /* tp_print */   	
	(getattrfunc)0,			    /* tp_getattr */ 	
	(setattrfunc)0,			    /* tp_setattr */ 	
#if PY_VERSION_HEX>=0x03000000
    0, /* tp_reserved in 3.0.1 */
#else
    (cmpfunc)SwigPyPacked_compare,	    /* tp_compare */
#endif
	(reprfunc)SwigPyPacked_repr,	    /* tp_repr */
	0,	                            /* tp_as_number */
	0,				    /* tp_as_sequence */
	0,				    /* tp_as_mapping */
	(hashfunc)0,			    /* tp_hash */
	(ternaryfunc)0,			    /* tp_call */
	(reprfunc)SwigPyPacked_str,	    /* tp_str */
	PyObject_GenericGetAttr,            /* tp_getattro */
	0,				    /* tp_setattro */
	0,		                    /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
	swigpacked_doc, 	            /* tp_doc */
	0,                                  /* tp_traverse */
	0,                                  /* tp_clear */
	0,                                  /* tp_richcompare */
	0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
	0,                                  /* tp_iter */
	0,                                  /* tp_iternext */
	0,		                    /* tp_methods */ 
	0,			            /* tp_members */
	0,				    /* tp_getset */	    	
	0,			            /* tp_base */	        
	0,				    /* tp_dict */	    	
	0,				    /* tp_descr_get */  	
	0,				    /* tp_descr_set */  	
	0,				    /* tp_dictoffset */ 	
	0,				    /* tp_init */	    	
	0,				    /* tp_alloc */	    	
	0,			            /* tp_new */	    	
	0, 	                            /* tp_free */	   
        0,                                  /* tp_is_gc */  
	0,				    /* tp_bases */   
	0,				    /* tp_mro */
	0,				    /* tp_cache */   
 	0,				    /* tp_subclasses */
	0,				    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
	0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
	0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
    swigpypacked_type = tmp;
    /* for Python 3 the ob_type already assigned in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    swigpypacked_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  static PyObject *SWIG_STATIC_POINTER(swig_this) = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  if (SwigPyObject_Check(pyobj)) {
    return (SwigPyObject *) pyobj;
  } else {
    PyObject *obj = 0;
#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
    if (PyInstance_Check(pyobj)) {
      obj = _PyInstance_Lookup(pyobj, SWIG_This());      
    } else {
      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
      } else {
#ifdef PyWeakref_CheckProxy
	if (PyWeakref_CheckProxy(pyobj)) {
	  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
	}
#endif
	obj = PyObject_GetAttr(pyobj,SWIG_This());
	if (obj) {
	  Py_DECREF(obj);
	} else {
	  if (PyErr_Occurred()) PyErr_Clear();
	  return 0;
	}
      }
    }
#else
    obj = PyObject_GetAttr(pyobj,SWIG_This());
    if (obj) {
      Py_DECREF(obj);
    } else {
      if (PyErr_Occurred()) PyErr_Clear();
      return 0;
    }
#endif
    if (obj && !SwigPyObject_Check(obj)) {
      /* a PyObject is called 'this', try to get the 'real this'
	 SwigPyObject from it */ 
      return SWIG_Python_GetSwigThis(obj);
    }
    return (SwigPyObject *)obj;
  }
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  if (!obj) return SWIG_ERROR;
  if (obj == Py_None) {
    if (ptr) *ptr = 0;
    return SWIG_OK;
  } else {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (own)
      *own = 0;
    while (sobj) {
      void *vptr = sobj->ptr;
      if (ty) {
	swig_type_info *to = sobj->ty;
	if (to == ty) {
	  /* no type cast needed */
	  if (ptr) *ptr = vptr;
	  break;
	} else {
	  swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
	  if (!tc) {
	    sobj = (SwigPyObject *)sobj->next;
	  } else {
	    if (ptr) {
              int newmemory = 0;
              *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
              if (newmemory == SWIG_CAST_NEW_MEMORY) {
                assert(own);
                if (own)
                  *own = *own | SWIG_CAST_NEW_MEMORY;
              }
            }
	    break;
	  }
	}
      } else {
	if (ptr) *ptr = vptr;
	break;
      }
    }
    if (sobj) {
      if (own)
        *own = *own | sobj->own;
      if (flags & SWIG_POINTER_DISOWN) {
	sobj->own = 0;
      }
      return SWIG_OK;
    } else {
      int res = SWIG_ERROR;
      if (flags & SWIG_POINTER_IMPLICIT_CONV) {
	SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
	if (data && !data->implicitconv) {
	  PyObject *klass = data->klass;
	  if (klass) {
	    PyObject *impconv;
	    data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
	    impconv = SWIG_Python_CallFunctor(klass, obj);
	    data->implicitconv = 0;
	    if (PyErr_Occurred()) {
	      PyErr_Clear();
	      impconv = 0;
	    }
	    if (impconv) {
	      SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
	      if (iobj) {
		void *vptr;
		res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
		if (SWIG_IsOK(res)) {
		  if (ptr) {
		    *ptr = vptr;
		    /* transfer the ownership to 'ptr' */
		    iobj->own = 0;
		    res = SWIG_AddCast(res);
		    res = SWIG_AddNewMask(res);
		  } else {
		    res = SWIG_AddCast(res);		    
		  }
		}
	      }
	      Py_DECREF(impconv);
	    }
	  }
	}
      }
      return res;
    }
  }
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    PyObject_SetAttr(inst, SWIG_This(), swig_this);
    Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
#else
    PyObject *dict = PyDict_New();
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst;
  PyObject *dict = PyDict_New();
  PyDict_SetItem(dict, SWIG_This(), swig_this);
  inst = PyInstance_NewRaw(data->newargs, dict);
  Py_DECREF(dict);
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args,(char*)"swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  if (!ptr) {
    return SWIG_Py_Void();
  } else {
    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
    PyObject *robj = SwigPyObject_New(ptr, type, own);
    SwigPyClientData *clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
      if (inst) {
	Py_DECREF(robj);
	robj = inst;
      }
    }
    return robj;
  }
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError,
		    "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError,
		    "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
SWIG_Python_DestroyModule(void *vptr)
{
  swig_module_info *swig_module = (swig_module_info *) vptr;
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */

#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				   swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
  } else {
    swig_module_info *swig_module = SWIG_Python_GetModule();
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : (char*)"";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}


#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_CBF_NODETYPE swig_types[0]
#define SWIGTYPE_p_a_4__double swig_types[1]
#define SWIGTYPE_p_a_4__doubleArray swig_types[2]
#define SWIGTYPE_p_cbf_axis_struct swig_types[3]
#define SWIGTYPE_p_cbf_detector_struct swig_types[4]
#define SWIGTYPE_p_cbf_handle_struct swig_types[5]
#define SWIGTYPE_p_cbf_node swig_types[6]
#define SWIGTYPE_p_cbf_positioner swig_types[7]
#define SWIGTYPE_p_cbf_positioner_struct swig_types[8]
#define SWIGTYPE_p_char swig_types[9]
#define SWIGTYPE_p_double swig_types[10]
#define SWIGTYPE_p_doubleArray swig_types[11]
#define SWIGTYPE_p_int swig_types[12]
#define SWIGTYPE_p_intArray swig_types[13]
#define SWIGTYPE_p_long swig_types[14]
#define SWIGTYPE_p_longArray swig_types[15]
#define SWIGTYPE_p_p_char swig_types[16]
#define SWIGTYPE_p_short swig_types[17]
#define SWIGTYPE_p_shortArray swig_types[18]
#define SWIGTYPE_p_size_t swig_types[19]
#define SWIGTYPE_p_void swig_types[20]
static swig_type_info *swig_types[22];
static swig_module_info swig_module = {swig_types, 21, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif

/*-----------------------------------------------
              @(target):= _pycbf.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__pycbf

#else
#  define SWIG_init    init_pycbf

#endif
#define SWIG_name    "_pycbf"

#define SWIGVERSION 0x010340 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


typedef double doubleArray;


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
  } else if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  return res;
}

SWIGINTERN doubleArray *new_doubleArray(size_t nelements){
    return (double *)malloc((nelements)*sizeof(double));
  }
SWIGINTERN void delete_doubleArray(doubleArray *self){
    free((char*)self);
  }
SWIGINTERN double doubleArray___getitem__(doubleArray *self,size_t index){
    return self[index];
  }

  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN void doubleArray___setitem__(doubleArray *self,size_t index,double value){
    self[index] = value;
  }
SWIGINTERN double *doubleArray_cast(doubleArray *self){
    return self;
  }
SWIGINTERN doubleArray *doubleArray_frompointer(double *t){
    return (doubleArray *)(t);
  }

typedef int intArray;

SWIGINTERN intArray *new_intArray(size_t nelements){
    return (int *)malloc((nelements)*sizeof(int));
  }
SWIGINTERN void delete_intArray(intArray *self){
    free((char*)self);
  }
SWIGINTERN int intArray___getitem__(intArray *self,size_t index){
    return self[index];
  }

  #define SWIG_From_long   PyInt_FromLong 


SWIGINTERNINLINE PyObject *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}

SWIGINTERN void intArray___setitem__(intArray *self,size_t index,int value){
    self[index] = value;
  }
SWIGINTERN int *intArray_cast(intArray *self){
    return self;
  }
SWIGINTERN intArray *intArray_frompointer(int *t){
    return (intArray *)(t);
  }

typedef short shortArray;

SWIGINTERN shortArray *new_shortArray(size_t nelements){
    return (short *)malloc((nelements)*sizeof(short));
  }
SWIGINTERN void delete_shortArray(shortArray *self){
    free((char*)self);
  }
SWIGINTERN short shortArray___getitem__(shortArray *self,size_t index){
    return self[index];
  }

SWIGINTERNINLINE PyObject *
SWIG_From_short  (short value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_short (PyObject * obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (short)(v);
    }
  }  
  return res;
}

SWIGINTERN void shortArray___setitem__(shortArray *self,size_t index,short value){
    self[index] = value;
  }
SWIGINTERN short *shortArray_cast(shortArray *self){
    return self;
  }
SWIGINTERN shortArray *shortArray_frompointer(short *t){
    return (shortArray *)(t);
  }

typedef long longArray;

SWIGINTERN longArray *new_longArray(size_t nelements){
    return (long *)malloc((nelements)*sizeof(long));
  }
SWIGINTERN void delete_longArray(longArray *self){
    free((char*)self);
  }
SWIGINTERN long longArray___getitem__(longArray *self,size_t index){
    return self[index];
  }
SWIGINTERN void longArray___setitem__(longArray *self,size_t index,long value){
    self[index] = value;
  }
SWIGINTERN long *longArray_cast(longArray *self){
    return self;
  }
SWIGINTERN longArray *longArray_frompointer(long *t){
    return (longArray *)(t);
  }

static int convert_darray(PyObject *input, double *ptr, int size) {
  int i;
  if (!PySequence_Check(input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return 0;
  }
  if (PyObject_Length(input) != size) {
      PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
      return 0;
  }
  for (i =0; i < size; i++) {
      PyObject *o = PySequence_GetItem(input,i);
     /*if (!PyFloat_Check(o)) {
        
         Py_XDECREF(o);
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return 0;
      }*/
      ptr[i] = PyFloat_AsDouble(o);
      Py_DECREF(o);
  }
  return 1;
}


    static long convert_larray(PyObject *input, long *ptr, int size) {
        int i;
        if (!PySequence_Check(input)) {
            PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
            return 0;
        }
        if (PyObject_Length(input) != size) {
            PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
            return 0;
        }
        for (i =0; i < size; i++) {
            PyObject *o = PySequence_GetItem(input,i);
            /*if (!PyLong_Check(o)) {
                Py_XDECREF(o);
                PyErr_SetString(PyExc_ValueError,"Expecting a sequence of long integers");
                return 0;
            }*/
            ptr[i] = PyLong_AsLong(o);
            Py_DECREF(o);
        }
        return 1;
    }


    static int convert_iarray(PyObject *input, int *ptr, int size) {
        int i;
        if (!PySequence_Check(input)) {
            PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
            return 0;
        }
        if (PyObject_Length(input) != size) {
            PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
            return 0;
        }
        for (i =0; i < size; i++) {
            PyObject *o = PySequence_GetItem(input,i);
            /*if (!PyInt_Check(o)) {
                Py_XDECREF(o);
                PyErr_SetString(PyExc_ValueError,"Expecting a sequence of long integers");
                return 0;
            }*/
            ptr[i] = (int)PyInt_AsLong(o);
            Py_DECREF(o);
        }
        return 1;
    }

  // Here is the c code needed to compile the wrappers, but not 
    // to be wrapped 

#include "../include/cbf.h"          
#include "../include/cbf_simple.h"

// Helper functions to generate error message
 

static int error_status = 0;
static char error_message[1024] ; // hope that is long enough

/* prototype */
void get_error_message(void);

void get_error_message(){
  sprintf(error_message,"%s","CBFlib Error(s):");
  if (error_status & CBF_FORMAT        )
    sprintf(error_message,"%s %s",error_message,"CBF_FORMAT       "); 
  if (error_status & CBF_ALLOC         )
    sprintf(error_message,"%s %s",error_message,"CBF_ALLOC        ");
  if (error_status & CBF_ARGUMENT      )
    sprintf(error_message,"%s %s",error_message,"CBF_ARGUMENT     ");
  if (error_status & CBF_ASCII         )
    sprintf(error_message,"%s %s",error_message,"CBF_ASCII        ");
  if (error_status & CBF_BINARY        )
    sprintf(error_message,"%s %s",error_message,"CBF_BINARY       ");
  if (error_status & CBF_BITCOUNT      )
    sprintf(error_message,"%s %s",error_message,"CBF_BITCOUNT     ");
  if (error_status & CBF_ENDOFDATA     )
    sprintf(error_message,"%s %s",error_message,"CBF_ENDOFDATA    ");
  if (error_status & CBF_FILECLOSE     )
    sprintf(error_message,"%s %s",error_message,"CBF_FILECLOSE    ");
  if (error_status & CBF_FILEOPEN      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILEOPEN     ");
  if (error_status & CBF_FILEREAD      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILEREAD     ");
  if (error_status & CBF_FILESEEK      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILESEEK     ");
  if (error_status & CBF_FILETELL      )
    sprintf(error_message,"%s %s",error_message,"CBF_FILETELL     ");
  if (error_status & CBF_FILEWRITE     )
    sprintf(error_message,"%s %s",error_message,"CBF_FILEWRITE    ");
  if (error_status & CBF_IDENTICAL     )
    sprintf(error_message,"%s %s",error_message,"CBF_IDENTICAL    ");
  if (error_status & CBF_NOTFOUND      )
    sprintf(error_message,"%s %s",error_message,"CBF_NOTFOUND     ");
  if (error_status & CBF_OVERFLOW      )
    sprintf(error_message,"%s %s",error_message,"CBF_OVERFLOW     ");
  if (error_status & CBF_UNDEFINED     )
    sprintf(error_message,"%s %s",error_message,"CBF_UNDEFINED    ");
  if (error_status & CBF_NOTIMPLEMENTED)
    sprintf(error_message,"%s %s",error_message,"CBF_NOTIMPLEMENTED");
  if (error_status & CBF_NOCOMPRESSION)
    sprintf(error_message,"%s %s",error_message,"CBF_NOCOMPRESSION");
}




  void get_local_integer_byte_order(char **bo, int *bolen) {
        char * byteorder;
        char * bot;
        error_status = cbf_get_local_integer_byte_order(&byteorder);
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
  }
  

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
      return PyUnicode_FromStringAndSize(carray, (int)(size));
#else
      return PyString_FromStringAndSize(carray, (int)(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


  void compute_cell_volume(double cell[6], double *volume) {
  {(error_status = cbf_compute_cell_volume(cell,volume));};
  }
  

  void get_local_real_format(char **rf, int *rflen) {
        char * real_format;
        char * rft;
        error_status = cbf_get_local_real_format(&real_format);
        *rflen = strlen(real_format);
        if (!(rft = (char *)malloc(*rflen))) {{(error_status = CBF_ALLOC);}}
        strncpy(rft,real_format,*rflen);
        *rf = rft;
  }
  

  void get_local_real_byte_order(char **bo, int *bolen) {
        char * byteorder;
        char * bot;
        error_status = cbf_get_local_real_byte_order(&byteorder);
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
  }
  

  void compute_reciprocal_cell(double cell[6], double *astar, double *bstar, double *cstar,
  double *alphastar, double *betastar, double *gammastar) {
    double rcell[6];
    {(error_status = cbf_compute_reciprocal_cell(cell,rcell));};
    *astar =      rcell[0];
    *bstar =      rcell[1];
    *cstar =      rcell[2];
    *alphastar =  rcell[3];
    *betastar =   rcell[4];
    *gammastar =  rcell[5];
  }
  

SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong((long)(value)); 
}


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
}

SWIGINTERN cbf_positioner_struct *new_cbf_positioner_struct(){  // Constructor
       // DO NOT CONSTRUCT WITHOUT A CBFHANDLE
       {(error_status = CBF_ARGUMENT);};
       return NULL; /* Should never be executed */
       }
SWIGINTERN void delete_cbf_positioner_struct(cbf_positioner_struct *self){ // Destructor
       {(error_status = cbf_free_goniometer(self));};
       }
SWIGINTERN void cbf_positioner_struct_get_rotation_range(cbf_positioner_struct *self,double *start,double *increment){
       unsigned int reserved;
       reserved = 0;
       {(error_status = cbf_get_rotation_range (self,reserved, start,increment));};
    }
SWIGINTERN void cbf_positioner_struct_rotate_vector(cbf_positioner_struct *self,double ratio,double initial1,double initial2,double initial3,double *final1,double *final2,double *final3){
       unsigned int reserved;
       reserved = 0;
       {(error_status = cbf_rotate_vector (self, reserved, ratio, initial1,
         initial2, initial3, final1, final2, final3));};
    }
SWIGINTERN void cbf_positioner_struct_get_reciprocal(cbf_positioner_struct *self,double ratio,double wavelength,double real1,double real2,double real3,double *reciprocal1,double *reciprocal2,double *reciprocal3){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_reciprocal(self,reserved, ratio, wavelength, 
                         real1, real2, real3,reciprocal1,
                         reciprocal2,reciprocal3));};
    }
SWIGINTERN void cbf_positioner_struct_get_rotation_axis(cbf_positioner_struct *self,double *vector1,double *vector2,double *vector3){
     unsigned int reserved;
     reserved = 0;
     {(error_status = cbf_get_rotation_axis (self, reserved, 
                                        vector1, vector2, vector3));};
    }
SWIGINTERN cbf_detector_struct *new_cbf_detector_struct(){  // Constructor
       // DO NOT CONSTRUCT WITHOUT A CBFHANDLE
       {(error_status = CBF_ARGUMENT);};
       return NULL; /* Should never be executed */
       }
SWIGINTERN void delete_cbf_detector_struct(cbf_detector_struct *self){ // Destructor
       {(error_status = cbf_free_detector(self));};
       }
SWIGINTERN void cbf_detector_struct_set_reference_beam_center_fs(cbf_detector_struct *self,double *indexfast,double *indexslow,double *centerfast,double *centerslow){
        {(error_status = cbf_set_reference_beam_center_fs(self, indexfast, indexslow, 
                                       centerfast, centerslow));};
        }
SWIGINTERN void cbf_detector_struct_get_pixel_coordinates_fs(cbf_detector_struct *self,double indexfast,double indexslow,double *coordinate1,double *coordinate2,double *coordinate3){
      {(error_status = cbf_get_pixel_coordinates_fs(self, indexfast, indexslow, coordinate1, coordinate2, coordinate3));};
   }
SWIGINTERN void cbf_detector_struct_set_beam_center_fs(cbf_detector_struct *self,double *indexfast,double *indexslow,double *centerfast,double *centerslow){
        {(error_status = cbf_set_beam_center_fs(self, indexfast, indexslow, 
                                       centerfast, centerslow));};
        }

SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}

SWIGINTERN void cbf_detector_struct_get_inferred_pixel_size(cbf_detector_struct *self,unsigned int axis_number,double *psize){
   {(error_status = cbf_get_inferred_pixel_size(self, axis_number, psize));};
   }
SWIGINTERN void cbf_detector_struct_get_pixel_area(cbf_detector_struct *self,double index1,double index2,double *area,double *projected_area){
       {(error_status = cbf_get_pixel_area (self,
                                       index1, index2, area,projected_area));};
      }
SWIGINTERN void cbf_detector_struct_get_pixel_normal_fs(cbf_detector_struct *self,double indexfast,double indexslow,double *normal1,double *normal2,double *normal3){
       {(error_status = cbf_get_pixel_normal_fs(self,
                                    indexfast,indexslow,normal1,normal2,normal3));};
   }
SWIGINTERN void cbf_detector_struct_get_detector_axes(cbf_detector_struct *self,double *slowaxis1,double *slowaxis2,double *slowaxis3,double *fastaxis1,double *fastaxis2,double *fastaxis3){
       {(error_status = cbf_get_detector_axes(self,
                                    slowaxis1,slowaxis2,slowaxis3,
                                    fastaxis1,fastaxis2,fastaxis3));};
   }
SWIGINTERN void cbf_detector_struct_set_reference_beam_center(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_reference_beam_center(self, indexslow, indexfast, 
                                       centerslow, centerfast));};
        }
SWIGINTERN void cbf_detector_struct_get_detector_axis_slow(cbf_detector_struct *self,double *slowaxis1,double *slowaxis2,double *slowaxis3){
       {(error_status = cbf_get_detector_axis_slow(self,
                                    slowaxis1,slowaxis2,slowaxis3));};
   }
SWIGINTERN void cbf_detector_struct_get_detector_distance(cbf_detector_struct *self,double *distance){
  {(error_status = cbf_get_detector_distance(self,distance));};
  }
SWIGINTERN void cbf_detector_struct_get_inferred_pixel_size_fs(cbf_detector_struct *self,unsigned int axis_number,double *psize){
   {(error_status = cbf_get_inferred_pixel_size_fs(self, axis_number, psize));};
   }
SWIGINTERN void cbf_detector_struct_get_detector_normal(cbf_detector_struct *self,double *normal1,double *normal2,double *normal3){
     {(error_status = cbf_get_detector_normal(self,
                    normal1, normal2, normal3));};
   }
SWIGINTERN void cbf_detector_struct_get_detector_axis_fast(cbf_detector_struct *self,double *fastaxis1,double *fastaxis2,double *fastaxis3){
       {(error_status = cbf_get_detector_axis_fast(self,
                                    fastaxis1,fastaxis2,fastaxis3));};
   }
SWIGINTERN void cbf_detector_struct_get_detector_axes_fs(cbf_detector_struct *self,double *fastaxis1,double *fastaxis2,double *fastaxis3,double *slowaxis1,double *slowaxis2,double *slowaxis3){
       {(error_status = cbf_get_detector_axes(self,
                                    slowaxis1,slowaxis2,slowaxis3,
                                    fastaxis1,fastaxis2,fastaxis3));};
   }
SWIGINTERN void cbf_detector_struct_get_detector_axes_sf(cbf_detector_struct *self,double *slowaxis1,double *slowaxis2,double *slowaxis3,double *fastaxis1,double *fastaxis2,double *fastaxis3){
       {(error_status = cbf_get_detector_axes(self,
                                    slowaxis1,slowaxis2,slowaxis3,
                                    fastaxis1,fastaxis2,fastaxis3));};
   }
SWIGINTERN void cbf_detector_struct_get_pixel_coordinates_sf(cbf_detector_struct *self,double indexslow,double indexfast,double *coordinate1,double *coordinate2,double *coordinate3){
      {(error_status = cbf_get_pixel_coordinates_sf(self, indexslow, indexfast, coordinate1, coordinate2, coordinate3));};
   }
SWIGINTERN void cbf_detector_struct_set_beam_center(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_beam_center(self, indexslow, indexfast, 
                                       centerslow, centerfast));};
        }
SWIGINTERN void cbf_detector_struct_get_pixel_area_fs(cbf_detector_struct *self,double indexfast,double indexslow,double *area,double *projected_area){
       {(error_status = cbf_get_pixel_area_fs (self,
                                       indexfast, indexslow, area,projected_area));};
      }
SWIGINTERN void cbf_detector_struct_get_beam_center_fs(cbf_detector_struct *self,double *indexfast,double *indexslow,double *centerfast,double *centerslow){
        {(error_status = cbf_get_beam_center_fs(self, indexfast, indexslow, 
                                       centerfast, centerslow));};
        }
SWIGINTERN void cbf_detector_struct_get_inferred_pixel_size_sf(cbf_detector_struct *self,unsigned int axis_number,double *psize){
   {(error_status = cbf_get_inferred_pixel_size_sf(self, axis_number, psize));};
   }
SWIGINTERN void cbf_detector_struct_get_pixel_coordinates(cbf_detector_struct *self,double index1,double index2,double *coordinate1,double *coordinate2,double *coordinate3){
      {(error_status = cbf_get_pixel_coordinates(self, index1, index2,
             coordinate1, coordinate2, coordinate3));};
   }
SWIGINTERN void cbf_detector_struct_get_beam_center_sf(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_get_beam_center_sf(self, indexslow, indexfast, 
                                       centerslow, centerfast));};
        }
SWIGINTERN void cbf_detector_struct_get_pixel_area_sf(cbf_detector_struct *self,double indexslow,double indexfast,double *area,double *projected_area){
       {(error_status = cbf_get_pixel_area_sf (self,
                                       indexslow, indexfast, area,projected_area));};
      }
SWIGINTERN void cbf_detector_struct_get_beam_center(cbf_detector_struct *self,double *index1,double *index2,double *center1,double *center2){
        {(error_status = cbf_get_beam_center(self, index1, index2, 
                                       center1, center2));};
        }
SWIGINTERN void cbf_detector_struct_set_reference_beam_center_sf(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_reference_beam_center_sf(self, indexslow, indexfast, 
                                       centerslow, centerfast));};
        }
SWIGINTERN void cbf_detector_struct_set_beam_center_sf(cbf_detector_struct *self,double *indexslow,double *indexfast,double *centerslow,double *centerfast){
        {(error_status = cbf_set_beam_center_sf(self, indexslow, indexfast, 
                                       centerslow, centerfast));};
        }
SWIGINTERN void cbf_detector_struct_get_pixel_normal(cbf_detector_struct *self,double index1,double index2,double *normal1,double *normal2,double *normal3){
       {(error_status = cbf_get_pixel_normal(self,
                                    index1,index2,normal1,normal2,normal3));};
   }
SWIGINTERN cbf_handle_struct *new_cbf_handle_struct(){  // Constructor
       cbf_handle handle;
       {(error_status = cbf_make_handle(&handle));};
       return handle;
       }
SWIGINTERN void delete_cbf_handle_struct(cbf_handle_struct *self){ // Destructor
       {(error_status = cbf_free_handle(self));};
       }
SWIGINTERN void cbf_handle_struct_select_datablock(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_datablock(self,arg));};}

SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
  if (PyUnicode_Check(obj))
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    PyBytes_AsStringAndSize(obj, &cstr, &len);
    if(alloc) *alloc = SWIG_NEWOBJ;
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	  {
	    *cptr = (char *)memcpy((char *)malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	    *alloc = SWIG_NEWOBJ;
	  }
	else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
        #if PY_VERSION_HEX>=0x03000000
        assert(0); /* Should never reach here in Python 3 */
        #endif
	*cptr = SWIG_Python_str_AsChar(obj);
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}




SWIGINTERN void cbf_handle_struct_force_new_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_force_new_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_3d_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_3d_image_fs(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimfast, (size_t)ndimmid, (size_t)ndimslow));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_reset_datablocks(cbf_handle_struct *self){
      {(error_status = cbf_reset_datablocks(self));};}
SWIGINTERN void cbf_handle_struct_set_tag_category(cbf_handle_struct *self,char const *tagname,char const *categoryname_in){
     {(error_status = cbf_set_tag_category(self,tagname, categoryname_in));};
     }
SWIGINTERN char const *cbf_handle_struct_require_tag_root(cbf_handle_struct *self,char const *tagname){
 const char* result;
 {(error_status = cbf_require_tag_root(self,tagname,&result));};
 return result;
 }

SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}

SWIGINTERN unsigned int cbf_handle_struct_row_number(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_row_number(self,&result));};
      return result;}

SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}

SWIGINTERN void cbf_handle_struct_set_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_bin_sizes(cbf_handle_struct *self,int element_number,double slowbinsize_in,double fastbinsize_in){
     {(error_status = cbf_set_bin_sizes(self,element_number,slowbinsize_in,fastbinsize_in));};
   }
SWIGINTERN void cbf_handle_struct_new_row(cbf_handle_struct *self){
      {(error_status = cbf_new_row(self));};}
SWIGINTERN void cbf_handle_struct_rewind_saveframe(cbf_handle_struct *self){
      {(error_status = cbf_rewind_saveframe(self));};}
SWIGINTERN void cbf_handle_struct_get_realarrayparameters(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements){
        unsigned int  comp;
        size_t elsiz, elem;
        {(error_status = cbf_get_realarrayparameters(self, 
                                 &comp ,binary_id, &elsiz, &elem ));};
        *compression = comp; /* FIXME - does this convert in C? */
        *elsize = elsiz;
        *elements = elem;
        }
SWIGINTERN void cbf_handle_struct_get_pixel_size_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double *psize){
        {(error_status = cbf_get_pixel_size_sf(self, 
                                       element_number, 
                                       axis_number, 
                                       psize));};
    }
SWIGINTERN void cbf_handle_struct_force_new_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_force_new_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_force_new_saveframe(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_force_new_saveframe(self,arg));};}
SWIGINTERN unsigned int cbf_handle_struct_count_datablocks(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_datablocks(self,&result));};
      return result;}
SWIGINTERN void cbf_handle_struct_find_row(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_row(self,arg));};}
SWIGINTERN void cbf_handle_struct_select_column(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_column(self,arg));};}
SWIGINTERN cbf_detector cbf_handle_struct_construct_detector(cbf_handle_struct *self,unsigned int element_number){
    cbf_detector detector;
    {(error_status = cbf_construct_detector(self,&detector,element_number));};
    return detector;
    }
SWIGINTERN void cbf_handle_struct_rewind_column(cbf_handle_struct *self){
      {(error_status = cbf_rewind_column(self));};}
SWIGINTERN void cbf_handle_struct_require_column_doublevalue(cbf_handle_struct *self,char const *columnname,double *number,double const defaultvalue){
    {(error_status = cbf_require_column_doublevalue(self,
                  columnname,number,defaultvalue));};
    }
SWIGINTERN void cbf_handle_struct_get_datestamp(cbf_handle_struct *self,int *year,int *month,int *day,int *hour,int *minute,double *second,int *timezone){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_datestamp(self,reserved,
              year,month,day,hour,minute,second,timezone));};
        }
SWIGINTERN int cbf_handle_struct_get_integervalue(cbf_handle_struct *self){
     int result;
       {(error_status = cbf_get_integervalue(self,&result));};
       return result;}
SWIGINTERN char const *cbf_handle_struct_get_crystal_id(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_crystal_id(self, &result));};
    return result;}
SWIGINTERN double cbf_handle_struct_get_doublevalue(cbf_handle_struct *self){
     double result;
       {(error_status = cbf_get_doublevalue(self,&result));};
       return result;}
SWIGINTERN void cbf_handle_struct_get_unit_cell(cbf_handle_struct *self,double *a,double *b,double *c,double *alpha,double *beta,double *gamma){
     double cell[6];
     {(error_status = cbf_get_unit_cell(self,cell,NULL));};
     *a = cell[0];
     *b = cell[1];
     *c = cell[2];
     *alpha = cell[3];
     *beta = cell[4];
     *gamma = cell[5];
   }
SWIGINTERN void cbf_handle_struct_get_unit_cell_esd(cbf_handle_struct *self,double *a_esd,double *b_esd,double *c_esd,double *alpha_esd,double *beta_esd,double *gamma_esd){
     double cell_esd[6];
     {(error_status = cbf_get_unit_cell(self,NULL,cell_esd));};
     *a_esd = cell_esd[0];
     *b_esd = cell_esd[1];
     *c_esd = cell_esd[2];
     *alpha_esd = cell_esd[3];
     *beta_esd = cell_esd[4];
     *gamma_esd = cell_esd[5];
   }
SWIGINTERN void cbf_handle_struct_remove_column(cbf_handle_struct *self){
      {(error_status = cbf_remove_column(self));};}
SWIGINTERN CBF_NODETYPE cbf_handle_struct_rewind_blockitem(cbf_handle_struct *self){
     CBF_NODETYPE result;
       {(error_status = cbf_rewind_blockitem(self,&result));};
       return result;}
SWIGINTERN char const *cbf_handle_struct_get_value(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_value(self, &result));};
    return result;}
SWIGINTERN unsigned int cbf_handle_struct_count_categories(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_categories(self,&result));};
      return result;}
SWIGINTERN void cbf_handle_struct_read_widefile(cbf_handle_struct *self,char *filename,int headers){
       /* CBFlib needs a stream that will remain open 
          hence DO NOT open from python */
       FILE *stream;
       if ( ! ( stream = fopen (filename, "rb")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
         {(error_status = cbf_read_widefile(self, stream, headers));}; 
    }
       }
SWIGINTERN void cbf_handle_struct_set_wavelength(cbf_handle_struct *self,double wavelength){
        {(error_status = cbf_set_wavelength(self,wavelength));};}
SWIGINTERN void cbf_handle_struct_set_pixel_size_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double psize){
         {(error_status = cbf_set_pixel_size_sf(self, 
                                        element_number, 
                                        axis_number, 
                                        psize));};
     }
SWIGINTERN char const *cbf_handle_struct_get_diffrn_id(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_diffrn_id(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_find_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_polarization(cbf_handle_struct *self,double *in1,double *in2){
        {(error_status = cbf_get_polarization (self, in1, in2));};
     }
SWIGINTERN void cbf_handle_struct_select_category(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_pixel_size_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double *psize){
        {(error_status = cbf_get_pixel_size_fs(self, 
                                       element_number, 
                                       axis_number, 
                                       psize));};
    }
SWIGINTERN void cbf_handle_struct_read_file(cbf_handle_struct *self,char *filename,int headers){
       /* CBFlib needs a stream that will remain open 
          hence DO NOT open from python */
       FILE *stream;
       if ( ! ( stream = fopen (filename, "rb")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
         {(error_status = cbf_read_file(self, stream, headers));}; 
    }
       }
SWIGINTERN char const *cbf_handle_struct_datablock_name(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_datablock_name(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_set_realarray_wdims(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?14:bolen] = 0;
           {(error_status = cbf_set_realarray_wdims (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, (size_t) elements, (const char *)byteorder,
           (size_t)dimfast, (size_t)dimmid, (size_t)dimslow, (size_t)padding));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN cbf_detector cbf_handle_struct_construct_reference_detector(cbf_handle_struct *self,unsigned int element_number){
    cbf_detector detector;
    {(error_status = cbf_construct_reference_detector(self,&detector,element_number));};
    return detector;
    }
SWIGINTERN void cbf_handle_struct_get_real_3d_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_real_3d_image_fs(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimfast, (size_t)ndimmid, (size_t)ndimslow));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_rewind_row(cbf_handle_struct *self){
      {(error_status = cbf_rewind_row(self));};}
SWIGINTERN void cbf_handle_struct_get_axis_setting(cbf_handle_struct *self,char const *axis_id,double *start,double *increment){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_get_axis_setting(self,reserved,axis_id,
                         start,increment));};
        }
SWIGINTERN void cbf_handle_struct_require_column(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_require_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_timestamp(cbf_handle_struct *self,double *time,int *timezone){
        unsigned int reserved;
        reserved = 0; 
        {(error_status = cbf_get_timestamp(self,reserved,time,timezone));};
        }
SWIGINTERN void cbf_handle_struct_find_nextrow(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_nextrow(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_realarrayparameters_wdims_sf(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements,char **bo,int *bolen,int *dimslow,int *dimmid,int *dimfast,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_realarrayparameters_wdims_sf(self, 
         &comp,binary_id, &elsiz, &elem, 
         &byteorder,&ds,&dm,&df,&pd ));};
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;
        
        }
SWIGINTERN void cbf_handle_struct_reset_datablock(cbf_handle_struct *self){
      {(error_status = cbf_reset_datablock(self));};}
SWIGINTERN void cbf_handle_struct_set_3d_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_3d_image_fs (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimfast, (size_t) ndimmid, (size_t)ndimslow));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_saveframename(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_saveframename(self,arg));};}
SWIGINTERN void cbf_handle_struct_require_integervalue(cbf_handle_struct *self,int *number,int thedefault){

     {(error_status = cbf_require_integervalue(self,number,thedefault));};

     }
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement){
        unsigned int  comp;
        size_t elsiz, elem;
        {(error_status = cbf_get_integerarrayparameters(self, 
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem, 
          minelement, maxelement));};
        *compression = comp; /* FIXME - does this convert in C? */
        *elsize = elsiz;
        *elements = elem;
        }
SWIGINTERN void cbf_handle_struct_set_real_3d_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_3d_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_write_file(cbf_handle_struct *self,char const *filename,int ciforcbf,int headers,int encoding){
       FILE *stream;
       int readable;
       /* Make the file non-0 to make CBFlib close the file */
       readable = 1;
       if ( ! ( stream = fopen (filename, "w+b")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
        {(error_status = cbf_write_file(self, stream, readable, 
                    ciforcbf, headers, encoding));};

        }
       }
SWIGINTERN void cbf_handle_struct_set_divergence(cbf_handle_struct *self,double div_x_source,double div_y_source,double div_x_y_source){
      {(error_status = cbf_set_divergence (self, div_x_source, 
                              div_y_source,div_x_y_source));};
      }
SWIGINTERN void cbf_handle_struct_remove_datablock(cbf_handle_struct *self){
      {(error_status = cbf_remove_datablock(self));};}
SWIGINTERN unsigned int cbf_handle_struct_count_elements(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_elements(self,&result));};
      return result;}
SWIGINTERN void cbf_handle_struct_set_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimfast,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimfast, (size_t)ndimslow));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN cbf_detector cbf_handle_struct_require_reference_detector(cbf_handle_struct *self,unsigned int element_number){
    cbf_detector detector;
    {(error_status = cbf_require_reference_detector(self,&detector,element_number));};
    return detector;
    }
SWIGINTERN void cbf_handle_struct_next_category(cbf_handle_struct *self){
      {(error_status = cbf_next_category(self));};}
SWIGINTERN void cbf_handle_struct_set_diffrn_id(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_diffrn_id(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_timestamp(cbf_handle_struct *self,double time,int timezone,double precision){
        unsigned int reserved;
        reserved = 0; 
        {(error_status = cbf_set_timestamp(self,reserved,time,timezone,precision));};
        }
SWIGINTERN void cbf_handle_struct_get_orientation_matrix(cbf_handle_struct *self,double *m0,double *m1,double *m2,double *m3,double *m4,double *m5,double *m6,double *m7,double *m8){
        double m[9];
        {(error_status = cbf_get_orientation_matrix(self,m));};
        *m0 = m[0]; *m1=m[1] ; *m2=m[2] ;
        *m3 = m[3]; *m4=m[4] ; *m5=m[5] ;
        *m6 = m[6]; *m7=m[7] ; *m8=m[8] ;
        }
SWIGINTERN void cbf_handle_struct_get_image_size_fs(cbf_handle_struct *self,unsigned int element_number,int *ndimfast,int *ndimslow){
        unsigned int reserved;
        size_t infast, inslow;
        reserved = 0;
        {(error_status = cbf_get_image_size_fs(self,reserved,element_number,&infast,&inslow));};
        *ndimfast = (int)infast; /* FIXME - is that how to convert? */
        *ndimslow = (int)inslow; 
        }
SWIGINTERN void cbf_handle_struct_get_divergence(cbf_handle_struct *self,double *div_x_source,double *div_y_source,double *div_x_y_source){
       {(error_status = cbf_get_divergence(self, 
                                     div_x_source, 
                                     div_y_source,
                                     div_x_y_source));}; 
       }
SWIGINTERN void cbf_handle_struct_rewind_category(cbf_handle_struct *self){
      {(error_status = cbf_rewind_category(self));};}
SWIGINTERN void cbf_handle_struct_read_template(cbf_handle_struct *self,char *filename){
       /* CBFlib needs a stream that will remain open 
        hence DO NOT open from python */
       FILE *stream;
       if ( ! ( stream = fopen (filename, "rb")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
        {(error_status = cbf_read_template (self, stream));}; }
    }
SWIGINTERN void cbf_handle_struct_select_row(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_select_row(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_image_fs(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimfast, (size_t)ndimslow));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_image_size_sf(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimfast){
        unsigned int reserved;
        size_t inslow, infast;
        reserved = 0;
        {(error_status = cbf_get_image_size(self,reserved,element_number,&inslow,&infast));};
        *ndimslow = (int)inslow;
        *ndimfast = (int)infast; 
        }
SWIGINTERN void cbf_handle_struct_get_real_image_fs_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimfast,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_real_image_fs(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimfast, (size_t)ndimslow));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN unsigned int cbf_handle_struct_count_columns(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_columns(self,&result));};
      return result;}
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters_wdims(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_integerarrayparameters_wdims(self, 
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem, 
          minelement, maxelement, &byteorder,&df,&dm,&ds,&pd ));};
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;
        
        }
SWIGINTERN void cbf_handle_struct_get_gain(cbf_handle_struct *self,unsigned int element_number,double *gain,double *gain_esd){
        {(error_status = cbf_get_gain (self, element_number, gain, gain_esd));};
        }
SWIGINTERN void cbf_handle_struct_new_saveframe(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_saveframe(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_polarization(cbf_handle_struct *self,double polarizn_source_ratio,double polarizn_source_norm){
         {(error_status = cbf_set_polarization(self,
                         polarizn_source_ratio,
                         polarizn_source_norm));};
     }
SWIGINTERN void cbf_handle_struct_set_real_3d_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_3d_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_delete_row(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_delete_row(self,arg));};}
SWIGINTERN char const *cbf_handle_struct_column_name(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_column_name(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_remove_saveframe(cbf_handle_struct *self){
      {(error_status = cbf_remove_saveframe(self));};}
SWIGINTERN void cbf_handle_struct_set_integerarray_wdims_sf(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements,char *bo,int bolen,int dimslow,int dimmid,int dimfast,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?14:bolen] = 0;
           {(error_status = cbf_set_integerarray_wdims_sf (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements, (const char *)byteorder,
           (size_t)dimslow, (size_t)dimmid, (size_t)dimfast, (size_t)padding));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN char const *cbf_handle_struct_require_value(cbf_handle_struct *self,char const *defaultvalue){
     const char * result;
     {(error_status = cbf_require_value(self, &result, defaultvalue));};
     return result;
    }
SWIGINTERN void cbf_handle_struct_require_column_integervalue(cbf_handle_struct *self,char const *columnname,int *number,int const defaultvalue){
    {(error_status = cbf_require_column_integervalue(self,
           columnname, number,defaultvalue));};
    }
SWIGINTERN void cbf_handle_struct_set_pixel_size(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double psize){
         {(error_status = cbf_set_pixel_size(self, 
                                        element_number, 
                                        axis_number, 
                                        psize));};
     }
SWIGINTERN void cbf_handle_struct_next_column(cbf_handle_struct *self){
      {(error_status = cbf_next_column(self));};}
SWIGINTERN void cbf_handle_struct_get_3d_image_size_sf(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimmid,int *ndimfast){
        unsigned int reserved;
        size_t inslow, inmid, infast;
        reserved = 0;
        {(error_status = cbf_get_3d_image_size_sf(self,reserved,element_number,&inslow,&inmid,&infast));};
        *ndimslow = (int)inslow; /* FIXME - is that how to convert? */
        *ndimmid = (int)inmid; 
        *ndimfast = (int)infast;
        }
SWIGINTERN void cbf_handle_struct_get_realarrayparameters_wdims_fs(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_realarrayparameters_wdims_fs(self, 
         &comp,binary_id, &elsiz, &elem, 
         &byteorder,&ds,&dm,&ds,&pd ));};
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;
        
        }
SWIGINTERN void cbf_handle_struct_get_realarray_as_string(cbf_handle_struct *self,char **s,int *slen){
        int binary_id;
        size_t elements, elements_read, elsize;
        unsigned int compression;
        void * array;
        *slen = 0; /* Initialise in case of problems */
        {(error_status = cbf_get_realarrayparameters(self, &compression,
               &binary_id, &elsize,
               &elements));};

        if ((array=malloc(elsize*elements))) {
              /* cbf_failnez (cbf_select_column(cbf,colnum)) */
               {(error_status = cbf_get_realarray(self, &binary_id, 
                            (void *)array, elsize,
                            elements, &elements_read));};

         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*elements;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_bin_sizes(cbf_handle_struct *self,int element_number,double *slowbinsize,double *fastbinsize){
    {(error_status = cbf_get_bin_sizes (self, (unsigned int)element_number, slowbinsize, fastbinsize));};
  }
SWIGINTERN void cbf_handle_struct_reset_category(cbf_handle_struct *self){
      {(error_status = cbf_reset_category(self));};}
SWIGINTERN cbf_goniometer cbf_handle_struct_construct_goniometer(cbf_handle_struct *self){
    cbf_goniometer goniometer;
    {(error_status = cbf_construct_goniometer(self,&goniometer));};
    return goniometer;
    }
SWIGINTERN void cbf_handle_struct_set_datablockname(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_datablockname(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_crystal_id(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_crystal_id(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_integerarray_as_string(cbf_handle_struct *self,char **s,int *slen){
        int binary_id, elsigned, elunsigned;
        size_t elements, elements_read, elsize;
        int minelement, maxelement;
        unsigned int compression;
        void * array;
        *slen = 0; /* Initialise in case of problems */
        {(error_status = cbf_get_integerarrayparameters(self, &compression,
               &binary_id, &elsize, &elsigned, &elunsigned,
               &elements, &minelement, &maxelement));};

        if ((array=malloc(elsize*elements))) {
              /* cbf_failnez (cbf_select_column(cbf,colnum)) */
               {(error_status = cbf_get_integerarray(self, &binary_id, 
                            (void *)array, elsize, elsigned,
                            elements, &elements_read));};

         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*elements;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_set_3d_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_3d_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t) ndimmid, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_dictionary(cbf_handle_struct *self,cbf_handle other){
   {(error_status = cbf_set_dictionary(self,other));};
}
SWIGINTERN char const *cbf_handle_struct_find_tag_category(cbf_handle_struct *self,char const *tagname){
     const char * result;
     {(error_status = cbf_find_tag_category(self,tagname, &result));};
     return result;
     }
SWIGINTERN void cbf_handle_struct_get_real_3d_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimmid,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_real_3d_image_sf(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_set_typeofvalue(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_typeofvalue(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_integerarray_wdims(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?14:bolen] = 0;
           {(error_status = cbf_set_integerarray_wdims (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements, (const char *)byteorder,
           (size_t)dimfast, (size_t)dimmid, (size_t)dimslow, (size_t)padding));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integration_time(cbf_handle_struct *self,double time){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_integration_time(self,reserved,time));};
        }
SWIGINTERN void cbf_handle_struct_set_axis_setting(cbf_handle_struct *self,char const *axis_id,double start,double increment){
        unsigned int reserved;
        reserved = 0;
        {(error_status = cbf_set_axis_setting(self,reserved,
                         axis_id,start,increment));};
        }
SWIGINTERN void cbf_handle_struct_get_real_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_real_image(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_3d_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_3d_image_sf(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_set_real_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimfast,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_image_fs (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimfast, (size_t)ndimslow));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_get_overload(cbf_handle_struct *self,unsigned int element_number,double *overload){
        {(error_status = cbf_get_overload(self,element_number,overload));};
        }
SWIGINTERN double cbf_handle_struct_get_wavelength(cbf_handle_struct *self){
     double result;
       {(error_status = cbf_get_wavelength(self,&result));};
       return result;}
SWIGINTERN void cbf_handle_struct_next_datablock(cbf_handle_struct *self){
      {(error_status = cbf_next_datablock(self));};}
SWIGINTERN void cbf_handle_struct_get_realarrayparameters_wdims(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elements,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_realarrayparameters_wdims(self, 
         &comp,binary_id, &elsiz, &elem, 
         &byteorder,&ds,&dm,&ds,&pd ));};
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;
        
        }
SWIGINTERN void cbf_handle_struct_set_orientation_matrix(cbf_handle_struct *self,double m0,double m1,double m2,double m3,double m4,double m5,double m6,double m7,double m8){
        double m[9];
        m[0] = m0; m[1]=m1 ; m[2]=m2 ;
        m[3] = m3; m[4]=m4 ; m[5]=m5 ;
        m[6] = m6; m[7]=m7 ; m[8]=m8 ;
        {(error_status = cbf_get_orientation_matrix(self,m));};
        }
SWIGINTERN void cbf_handle_struct_new_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_gain(cbf_handle_struct *self,unsigned int element_number,double gain,double gain_esd){
        {(error_status = cbf_set_gain (self, element_number, gain, gain_esd));};
        }
SWIGINTERN void cbf_handle_struct_find_column(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_remove_category(cbf_handle_struct *self){
      {(error_status = cbf_remove_category(self));};}
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters_wdims_sf(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement,char **bo,int *bolen,int *dimslow,int *dimmid,int *dimfast,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_integerarrayparameters_wdims_sf(self, 
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem, 
          minelement, maxelement, &byteorder,&ds,&dm,&df,&pd ));};
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp;
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;
        
        }
SWIGINTERN void cbf_handle_struct_get_pixel_size(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double *psize){
        {(error_status = cbf_get_pixel_size(self, 
                                       element_number, 
                                       axis_number, 
                                       psize));};
    }
SWIGINTERN void cbf_handle_struct_set_real_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_require_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_require_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_reciprocal_cell(cbf_handle_struct *self,double *astar,double *bstar,double *cstar,double *alphastar,double *betastar,double *gammastar){
     double rcell[6];
     {(error_status = cbf_get_reciprocal_cell(self,rcell,NULL));};
    *astar =      rcell[0];
    *bstar =      rcell[1];
    *cstar =      rcell[2];
    *alphastar =  rcell[3];
    *betastar =   rcell[4];
    *gammastar =  rcell[5];
   }
SWIGINTERN void cbf_handle_struct_get_reciprocal_cell_esd(cbf_handle_struct *self,double *a_esd,double *b_esd,double *c_esd,double *alpha_esd,double *beta_esd,double *gamma_esd){
     double cell_esd[6];
     {(error_status = cbf_get_reciprocal_cell(self,NULL,cell_esd));};
     *a_esd = cell_esd[0];
     *b_esd = cell_esd[1];
     *c_esd = cell_esd[2];
     *alpha_esd = cell_esd[3];
     *beta_esd = cell_esd[4];
     *gamma_esd = cell_esd[5];
   }
SWIGINTERN void cbf_handle_struct_get_3d_image_size(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimmid,int *ndimfast){
        unsigned int reserved;
        size_t inslow, inmid, infast;
        reserved = 0;
        {(error_status = cbf_get_3d_image_size(self,reserved,element_number,&inslow,&inmid,&infast));};
        *ndimslow = (int)inslow; /* FIXME - is that how to convert? */
        *ndimmid = (int)inmid; 
        *ndimfast = (int)infast;
        }
SWIGINTERN char const *cbf_handle_struct_find_tag_root(cbf_handle_struct *self,char const *tagname){
   const char* result;
   {(error_status = cbf_find_tag_root(self,tagname,&result));};
   return result;
}
SWIGINTERN char const *cbf_handle_struct_require_category_root(cbf_handle_struct *self,char const *categoryname){
  const char* result;
  {(error_status = cbf_require_category_root(self,categoryname, &result));};
  return result;
}
SWIGINTERN void cbf_handle_struct_set_realarray_wdims_sf(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements,char *bo,int bolen,int dimslow,int dimmid,int dimfast,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?14:bolen] = 0;
           {(error_status = cbf_set_realarray_wdims_sf (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, (size_t) elements, (const char *)byteorder,
           (size_t) dimslow, (size_t) dimmid, (size_t) dimfast, (size_t)padding));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_integervalue(cbf_handle_struct *self,int number){
        {(error_status = cbf_set_integervalue(self,number));};}
SWIGINTERN char const *cbf_handle_struct_category_name(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_category_name(self, &result));};
    return result;}
SWIGINTERN char const *cbf_handle_struct_get_typeofvalue(cbf_handle_struct *self){
    const char* result;
    {(error_status = cbf_get_typeofvalue(self, &result));};
    return result;}
SWIGINTERN void cbf_handle_struct_set_real_image(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_image (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimslow, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_get_3d_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimfast,int ndimmid,int ndimslow){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_3d_image(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_remove_row(cbf_handle_struct *self){
      {(error_status = cbf_remove_row(self));};}
SWIGINTERN void cbf_handle_struct_set_overload(cbf_handle_struct *self,unsigned int element_number,double overload){
        {(error_status = cbf_set_overload(self,element_number,overload));};
        }
SWIGINTERN void cbf_handle_struct_get_image_size(cbf_handle_struct *self,unsigned int element_number,int *ndimslow,int *ndimfast){
        unsigned int reserved;
        size_t inslow, infast;
        reserved = 0;
        {(error_status = cbf_get_image_size(self,reserved,element_number,&inslow,&infast));};
        *ndimslow = (int)inslow;
        *ndimfast = (int)infast; 
        }
SWIGINTERN void cbf_handle_struct_set_3d_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimmid,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_3d_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t) ndimmid, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_get_real_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_real_image_sf(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_image(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_set_tag_root(cbf_handle_struct *self,char const *tagname,char const *tagroot_in){
   {(error_status = cbf_set_tag_root(self,tagname,tagroot_in));};
}
SWIGINTERN void cbf_handle_struct_write_widefile(cbf_handle_struct *self,char const *filename,int ciforcbf,int headers,int encoding){
       FILE *stream;
       int readable;
       /* Make the file non-0 to make CBFlib close the file */
       readable = 1;
       if ( ! ( stream = fopen (filename, "w+b")) ){
         {(error_status = CBF_FILEOPEN);};
        }
        else{
        {(error_status = cbf_write_widefile(self, stream, readable, 
                    ciforcbf, headers, encoding));};

        }
       }
SWIGINTERN unsigned int cbf_handle_struct_count_rows(cbf_handle_struct *self){
      unsigned int result;
      {(error_status = cbf_count_rows(self,&result));};
      return result;}
SWIGINTERN void cbf_handle_struct_require_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_require_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_integerarray(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements){
        /* safety check on args */
        size_t els, ele;
        void *array;
        if(len == elsize*elements){
           array = data;
           els = elsize;
           ele = elements;
           {(error_status = cbf_set_integerarray (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_new_datablock(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_datablock(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_datestamp(cbf_handle_struct *self,int year,int month,int day,int hour,int minute,double second,int timezone,double precision){
        unsigned int reserved;
        reserved = 0; 
        {(error_status = cbf_set_datestamp(self,reserved, 
              year,month,day,hour,minute,second,timezone,precision));};
        }
SWIGINTERN void cbf_handle_struct_next_row(cbf_handle_struct *self){
      {(error_status = cbf_next_row(self));};}
SWIGINTERN void cbf_handle_struct_set_category_root(cbf_handle_struct *self,char const *categoryname,char const *categoryroot){
   {(error_status = cbf_set_category_root(self,categoryname,categoryroot));};
}
SWIGINTERN void cbf_handle_struct_set_pixel_size_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int axis_number,double psize){
         {(error_status = cbf_set_pixel_size_fs(self, 
                                        element_number, 
                                        axis_number, 
                                        psize));};
     }
SWIGINTERN void cbf_handle_struct_insert_row(cbf_handle_struct *self,unsigned int arg){
      {(error_status = cbf_insert_row(self,arg));};}
SWIGINTERN void cbf_handle_struct_new_column(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_new_column(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_real_3d_image_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int ndimslow,int ndimmid,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimmid*ndimslow))) {
               {(error_status = cbf_get_real_3d_image(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize,
               (size_t) ndimslow, (size_t)ndimmid, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimmid*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_integration_time(cbf_handle_struct *self,double *time){
        unsigned int reserved;
        double tim;
        reserved = 0;
        {(error_status = cbf_get_integration_time(self,reserved,&tim));};
        *time = tim;
        }
SWIGINTERN void cbf_handle_struct_set_realarray(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements){
        /* safety check on args */
        size_t els, ele;
        void *array;
        if(len == elsize*elements){
           array = data;
           els = elsize;
           ele = elements;
           {(error_status = cbf_set_realarray (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, (size_t) elements));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN char const *cbf_handle_struct_get_element_id(cbf_handle_struct *self,unsigned int element_number){
       const char * result;
       {(error_status = cbf_get_element_id (self, element_number, &result));};
       return result;
       }
SWIGINTERN void cbf_handle_struct_get_image_sf_as_string(cbf_handle_struct *self,int element_number,char **s,int *slen,int elsize,int elsign,int ndimslow,int ndimfast){
        void *array;
        int reserved = 0;
        *slen = 0; /* Initialise in case of problems */
        if ((array=malloc(elsize*ndimfast*ndimslow))) {
               {(error_status = cbf_get_image_sf(self, 
               reserved, (unsigned int)element_number,
               (void *)array, (size_t)elsize, elsign,
               (size_t) ndimslow, (size_t)ndimfast));};
         }else{
               {(error_status = CBF_ALLOC);};
         }
        *slen = elsize*ndimfast*ndimslow;
        *s = (char *) array;
      }
SWIGINTERN void cbf_handle_struct_get_3d_image_size_fs(cbf_handle_struct *self,unsigned int element_number,int *ndimfast,int *ndimmid,int *ndimslow){
        unsigned int reserved;
        size_t inslow, inmid, infast;
        reserved = 0;
        {(error_status = cbf_get_3d_image_size_fs(self,reserved,element_number,&infast,&inmid,&inslow));};
        *ndimslow = (int)inslow; /* FIXME - is that how to convert? */
        *ndimmid = (int)inmid; 
        *ndimfast = (int)infast;
        }
SWIGINTERN void cbf_handle_struct_set_value(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_set_value(self,arg));};}
SWIGINTERN void cbf_handle_struct_set_current_timestamp(cbf_handle_struct *self,int timezone){
        unsigned int reserved;
        reserved = 0; 
        {(error_status = cbf_set_current_timestamp(self,reserved,timezone));};
        }
SWIGINTERN void cbf_handle_struct_require_doublevalue(cbf_handle_struct *self,double *number,double defaultvalue){
   {(error_status = cbf_require_doublevalue(self,number,defaultvalue));};
}
SWIGINTERN void cbf_handle_struct_rewind_datablock(cbf_handle_struct *self){
      {(error_status = cbf_rewind_datablock(self));};}
SWIGINTERN char const *cbf_handle_struct_require_column_value(cbf_handle_struct *self,char const *columnname,char const *defaultvalue){
   const char * result;
   {(error_status = cbf_require_column_value(self,columnname,
                                    &result,defaultvalue));};
   return result;
}
SWIGINTERN cbf_handle cbf_handle_struct_get_dictionary(cbf_handle_struct *self){
   cbf_handle temp;
   {(error_status = cbf_get_dictionary(self,&temp));};
   return temp;
}
SWIGINTERN void cbf_handle_struct_reset_saveframe(cbf_handle_struct *self){
      {(error_status = cbf_reset_saveframe(self));};}
SWIGINTERN void cbf_handle_struct_set_reciprocal_cell(cbf_handle_struct *self,double cell[6]){
     {(error_status = cbf_set_reciprocal_cell(self,cell,NULL));};
   }
SWIGINTERN void cbf_handle_struct_set_reciprocal_cell_esd(cbf_handle_struct *self,double cell_esd[6]){
     {(error_status = cbf_set_reciprocal_cell(self,NULL,cell_esd));};
   }
SWIGINTERN void cbf_handle_struct_set_real_3d_image_fs(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int ndimfast,int ndimmid,int ndimslow){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimmid*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_real_3d_image_fs (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, (size_t) ndimfast, (size_t)ndimmid, (size_t)ndimslow));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_doublevalue(cbf_handle_struct *self,char const *format,double number){
        {(error_status = cbf_set_doublevalue(self,format,number));};}
SWIGINTERN void cbf_handle_struct_find_category(cbf_handle_struct *self,char const *arg){
      {(error_status = cbf_find_category(self,arg));};}
SWIGINTERN void cbf_handle_struct_get_integerarrayparameters_wdims_fs(cbf_handle_struct *self,int *compression,int *binary_id,int *elsize,int *elsigned,int *elunsigned,int *elements,int *minelement,int *maxelement,char **bo,int *bolen,int *dimfast,int *dimmid,int *dimslow,int *padding){
        unsigned int  comp;
        size_t elsiz, elem, df,dm,ds,pd;
        const char * byteorder;
        char * bot;
        {(error_status = cbf_get_integerarrayparameters_wdims_fs(self, 
         &comp,binary_id, &elsiz, elsigned, elunsigned, &elem, 
          minelement, maxelement, &byteorder,&df,&dm,&ds,&pd ));};
        *bolen = strlen(byteorder);
        if (!(bot = (char *)malloc(*bolen))) {{(error_status = CBF_ALLOC);}}
        strncpy(bot,byteorder,*bolen);
        *bo = bot;
        *compression = comp; 
        *elsize = elsiz;
        *elements = elem;
        *dimfast = df;
        *dimmid = dm;
        *dimslow = ds;
        *padding = pd;
        
        }
SWIGINTERN void cbf_handle_struct_set_realarray_wdims_fs(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?14:bolen] = 0;
           {(error_status = cbf_set_realarray_wdims_fs (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, (size_t) elements, (const char *)byteorder,
           (size_t) dimfast, (size_t) dimmid, (size_t) dimslow, (size_t)padding));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN char const *cbf_handle_struct_find_category_root(cbf_handle_struct *self,char const *categoryname){
   const char * result;
   {(error_status = cbf_find_category_root(self,categoryname,&result));};
   return result;
}
SWIGINTERN void cbf_handle_struct_set_integerarray_wdims_fs(cbf_handle_struct *self,unsigned int compression,int binary_id,char *data,int len,int elsize,int elsigned,int elements,char *bo,int bolen,int dimfast,int dimmid,int dimslow,int padding){
        /* safety check on args */
        size_t els, ele;
        void *array;
        char byteorder[15];
        if(len == elsize*elements && elements==dimfast*dimmid*dimslow){
           array = data;
           els = elsize;
           ele = elements;
           strncpy(byteorder,bo,bolen<15?bolen:14);
           byteorder[bolen<15?14:bolen] = 0;
           {(error_status = cbf_set_integerarray_wdims_fs (self, compression, binary_id, 
           (void *) data,  (size_t) elsize, elsigned, (size_t) elements, (const char *)byteorder,
           (size_t)dimfast, (size_t)dimmid, (size_t)dimslow, (size_t)padding));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_image_sf(cbf_handle_struct *self,unsigned int element_number,unsigned int compression,char *data,int len,int elsize,int elsign,int ndimslow,int ndimfast){
        /* safety check on args */
        size_t els;
        unsigned int reserved;
        void *array;
        if(len == elsize*ndimslow*ndimfast){
           array = data;
           els = elsize;
           reserved = 0;
           {(error_status = cbf_set_image_sf (self, reserved, element_number, compression,
           (void *) data,  (size_t) elsize, elsign, (size_t) ndimslow, (size_t)ndimfast));}; 
        }else{
           {(error_status = CBF_ARGUMENT);};
        }
    }
SWIGINTERN void cbf_handle_struct_set_unit_cell(cbf_handle_struct *self,double cell[6]){
     {(error_status = cbf_set_unit_cell(self,cell,NULL));};
   }
SWIGINTERN void cbf_handle_struct_set_unit_cell_esd(cbf_handle_struct *self,double cell_esd[6]){
     {(error_status = cbf_set_unit_cell(self,NULL,cell_esd));};
   }
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_new_doubleArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  doubleArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_doubleArray",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_doubleArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (doubleArray *)new_doubleArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_doubleArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_doubleArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_doubleArray",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_doubleArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_doubleArray" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  delete_doubleArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:doubleArray___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_doubleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray___getitem__" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "doubleArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (double)doubleArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  size_t arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:doubleArray___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_doubleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray___setitem__" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "doubleArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "doubleArray___setitem__" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  doubleArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  doubleArray *arg1 = (doubleArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:doubleArray_cast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_doubleArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray_cast" "', argument " "1"" of type '" "doubleArray *""'"); 
  }
  arg1 = (doubleArray *)(argp1);
  result = (double *)doubleArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doubleArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  doubleArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:doubleArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "doubleArray_frompointer" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = (double *)(argp1);
  result = (doubleArray *)doubleArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_doubleArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *doubleArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_doubleArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_intArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  intArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_intArray",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_intArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (intArray *)new_intArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_intArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_intArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_intArray",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_intArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_intArray" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  delete_intArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:intArray___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_intArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray___getitem__" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "intArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (int)intArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  size_t arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:intArray___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_intArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray___setitem__" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "intArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "intArray___setitem__" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  intArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  intArray *arg1 = (intArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:intArray_cast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_intArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray_cast" "', argument " "1"" of type '" "intArray *""'"); 
  }
  arg1 = (intArray *)(argp1);
  result = (int *)intArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_intArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int *arg1 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  intArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:intArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "intArray_frompointer" "', argument " "1"" of type '" "int *""'"); 
  }
  arg1 = (int *)(argp1);
  result = (intArray *)intArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_intArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *intArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_intArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_shortArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  shortArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_shortArray",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_shortArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (shortArray *)new_shortArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_shortArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_shortArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_shortArray",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_shortArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_shortArray" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  delete_shortArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  short result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:shortArray___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_shortArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray___getitem__" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "shortArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (short)shortArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_short((short)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  size_t arg2 ;
  short arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  short val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:shortArray___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_shortArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray___setitem__" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "shortArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_short(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "shortArray___setitem__" "', argument " "3"" of type '" "short""'");
  } 
  arg3 = (short)(val3);
  shortArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  shortArray *arg1 = (shortArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  short *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:shortArray_cast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_shortArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray_cast" "', argument " "1"" of type '" "shortArray *""'"); 
  }
  arg1 = (shortArray *)(argp1);
  result = (short *)shortArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_short, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shortArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  short *arg1 = (short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  shortArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:shortArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_short, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "shortArray_frompointer" "', argument " "1"" of type '" "short *""'"); 
  }
  arg1 = (short *)(argp1);
  result = (shortArray *)shortArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_shortArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *shortArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_shortArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_longArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  longArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_longArray",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_longArray" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  result = (longArray *)new_longArray(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_longArray, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_longArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_longArray",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_longArray, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_longArray" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  delete_longArray(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:longArray___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_longArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray___getitem__" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "longArray___getitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  result = (long)longArray___getitem__(arg1,arg2);
  resultobj = SWIG_From_long((long)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  size_t arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:longArray___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_longArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray___setitem__" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "longArray___setitem__" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "longArray___setitem__" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = (long)(val3);
  longArray___setitem__(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  longArray *arg1 = (longArray *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:longArray_cast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_longArray, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray_cast" "', argument " "1"" of type '" "longArray *""'"); 
  }
  arg1 = (longArray *)(argp1);
  result = (long *)longArray_cast(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_long, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_longArray_frompointer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  long *arg1 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  longArray *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:longArray_frompointer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "longArray_frompointer" "', argument " "1"" of type '" "long *""'"); 
  }
  arg1 = (long *)(argp1);
  result = (longArray *)longArray_frompointer(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_longArray, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *longArray_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_longArray, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_get_local_integer_byte_order(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char **arg1 = (char **) 0 ;
  int *arg2 = (int *) 0 ;
  char *temp1 = 0 ;
  int tempn1 ;
  
  arg1 = &temp1; arg2 = &tempn1;
  if (!PyArg_ParseTuple(args,(char *)":get_local_integer_byte_order")) SWIG_fail;
  {
    error_status=0;
    get_local_integer_byte_order(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg1) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg1,*arg2));
    free(*arg1);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_cell_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 = (double *) 0 ;
  double temp1[6] ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  if (!PyArg_ParseTuple(args,(char *)"O:compute_cell_volume",&obj0)) SWIG_fail;
  {
    if (obj0 == Py_None) arg1 = NULL;
    else 
    if (!convert_darray(obj0,temp1,6)) {
      return NULL;
    }
    arg1 = &temp1[0];
  }
  {
    error_status=0;
    compute_cell_volume(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_local_real_format(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char **arg1 = (char **) 0 ;
  int *arg2 = (int *) 0 ;
  char *temp1 = 0 ;
  int tempn1 ;
  
  arg1 = &temp1; arg2 = &tempn1;
  if (!PyArg_ParseTuple(args,(char *)":get_local_real_format")) SWIG_fail;
  {
    error_status=0;
    get_local_real_format(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg1) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg1,*arg2));
    free(*arg1);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_get_local_real_byte_order(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char **arg1 = (char **) 0 ;
  int *arg2 = (int *) 0 ;
  char *temp1 = 0 ;
  int tempn1 ;
  
  arg1 = &temp1; arg2 = &tempn1;
  if (!PyArg_ParseTuple(args,(char *)":get_local_real_byte_order")) SWIG_fail;
  {
    error_status=0;
    get_local_real_byte_order(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg1) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg1,*arg2));
    free(*arg1);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_compute_reciprocal_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  double *arg1 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double temp1[6] ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:compute_reciprocal_cell",&obj0)) SWIG_fail;
  {
    if (obj0 == Py_None) arg1 = NULL;
    else 
    if (!convert_darray(obj0,temp1,6)) {
      return NULL;
    }
    arg1 = &temp1[0];
  }
  {
    error_status=0;
    compute_reciprocal_cell(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double (*arg2)[4] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_positioner_struct_matrix_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_a_4__double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_positioner_struct_matrix_set" "', argument " "2"" of type '" "double [3][4]""'"); 
  } 
  arg2 = (double (*)[4])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)4; ++jj) arg1->matrix[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""matrix""' of type '""double [3][4]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""matrix""' of type '""double [3][4]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double (*result)[4] = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_matrix_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (double (*)[4])(double (*)[4]) ((arg1)->matrix);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a_4__double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axis_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  cbf_axis_struct *arg2 = (cbf_axis_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_positioner_struct_axis_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axis_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cbf_axis_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_positioner_struct_axis_set" "', argument " "2"" of type '" "cbf_axis_struct *""'"); 
  }
  arg2 = (cbf_axis_struct *)(argp2);
  if (arg1) (arg1)->axis = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axis_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cbf_axis_struct *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_axis_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axis_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (cbf_axis_struct *) ((arg1)->axis);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_axis_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axes_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_positioner_struct_axes_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axes_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_axes_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->axes = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axes_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_axes_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axes_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result =  ((arg1)->axes);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_is_valid_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_positioner_struct_matrix_is_valid_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_is_valid_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_matrix_is_valid_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->matrix_is_valid = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_matrix_is_valid_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_matrix_is_valid_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_matrix_is_valid_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (int) ((arg1)->matrix_is_valid);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axes_are_connected_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_positioner_struct_axes_are_connected_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axes_are_connected_set" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_axes_are_connected_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->axes_are_connected = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_axes_are_connected_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_axes_are_connected_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_axes_are_connected_get" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  result = (int) ((arg1)->axes_are_connected);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_cbf_positioner_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_cbf_positioner_struct")) SWIG_fail;
  {
    error_status=0;
    result = (cbf_positioner_struct *)new_cbf_positioner_struct();
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_cbf_positioner_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_cbf_positioner_struct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cbf_positioner_struct" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  {
    error_status=0;
    delete_cbf_positioner_struct(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_rotation_range(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_get_rotation_range",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_rotation_range" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  {
    error_status=0;
    cbf_positioner_struct_get_rotation_range(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_rotate_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_positioner_struct_rotate_vector",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_positioner_struct_rotate_vector" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    error_status=0;
    cbf_positioner_struct_rotate_vector(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_reciprocal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_positioner_struct_get_reciprocal",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_positioner_struct_get_reciprocal" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    error_status=0;
    cbf_positioner_struct_get_reciprocal(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_positioner_struct_get_rotation_axis(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_positioner_struct *arg1 = (cbf_positioner_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_positioner_struct_get_rotation_axis",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_positioner_struct_get_rotation_axis" "', argument " "1"" of type '" "cbf_positioner_struct *""'"); 
  }
  arg1 = (cbf_positioner_struct *)(argp1);
  {
    error_status=0;
    cbf_positioner_struct_get_rotation_axis(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *cbf_positioner_struct_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_cbf_positioner_struct, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_cbf_detector_struct_positioner_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  cbf_positioner arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_positioner_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_positioner_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_cbf_positioner,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_positioner_set" "', argument " "2"" of type '" "cbf_positioner""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cbf_detector_struct_positioner_set" "', argument " "2"" of type '" "cbf_positioner""'");
    } else {
      arg2 = *((cbf_positioner *)(argp2));
    }
  }
  if (arg1) (arg1)->positioner = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_positioner_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cbf_positioner result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_positioner_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_positioner_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result =  ((arg1)->positioner);
  resultobj = SWIG_NewPointerObj((cbf_positioner *)memcpy((cbf_positioner *)malloc(sizeof(cbf_positioner)),&result,sizeof(cbf_positioner)), SWIGTYPE_p_cbf_positioner, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_displacement_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[2] ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_displacement_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_displacement_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    if (obj1 == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(obj1,temp2,2)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->displacement[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""displacement""' of type '""double [2]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_displacement_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_displacement_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_displacement_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (double *)(double *) ((arg1)->displacement);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_increment_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[2] ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_increment_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_increment_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    if (obj1 == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(obj1,temp2,2)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->increment[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""increment""' of type '""double [2]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_increment_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_increment_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_increment_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (double *)(double *) ((arg1)->increment);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_axes_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_axes_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_axes_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_axes_set" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  if (arg1) (arg1)->axes = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_axes_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_axes_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_axes_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result =  ((arg1)->axes);
  resultobj = SWIG_From_size_t((size_t)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_index_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  size_t *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_index_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_index_set" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_size_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_index_set" "', argument " "2"" of type '" "size_t [2]""'"); 
  } 
  arg2 = (size_t *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->index[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""index""' of type '""size_t [2]""'");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_index_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  size_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_index_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_index_get" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  result = (size_t *)(size_t *) ((arg1)->index);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_cbf_detector_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_cbf_detector_struct")) SWIG_fail;
  {
    error_status=0;
    result = (cbf_detector_struct *)new_cbf_detector_struct();
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_cbf_detector_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_cbf_detector_struct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cbf_detector_struct" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    delete_cbf_detector_struct(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_reference_beam_center_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_detector_struct_set_reference_beam_center_fs",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_reference_beam_center_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_set_reference_beam_center_fs" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_detector_struct_set_reference_beam_center_fs" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_detector_struct_set_reference_beam_center_fs" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cbf_detector_struct_set_reference_beam_center_fs" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    error_status=0;
    cbf_detector_struct_set_reference_beam_center_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_coordinates_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_coordinates_fs",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_coordinates_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_coordinates_fs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_coordinates_fs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_coordinates_fs(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_beam_center_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_detector_struct_set_beam_center_fs",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_beam_center_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_set_beam_center_fs" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_detector_struct_set_beam_center_fs" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_detector_struct_set_beam_center_fs" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cbf_detector_struct_set_beam_center_fs" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    error_status=0;
    cbf_detector_struct_set_beam_center_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_inferred_pixel_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_get_inferred_pixel_size",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_inferred_pixel_size" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_inferred_pixel_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_detector_struct_get_inferred_pixel_size(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_area(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_area",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_area" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_area" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_area" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_area(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_normal_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_normal_fs",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_normal_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_normal_fs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_normal_fs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_normal_fs(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_axes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axes" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axes(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_reference_beam_center(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_detector_struct_set_reference_beam_center",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_reference_beam_center" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_set_reference_beam_center" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_detector_struct_set_reference_beam_center" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_detector_struct_set_reference_beam_center" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cbf_detector_struct_set_reference_beam_center" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    error_status=0;
    cbf_detector_struct_set_reference_beam_center(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axis_slow(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_axis_slow",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axis_slow" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axis_slow(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_distance",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_distance" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_distance(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_inferred_pixel_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_get_inferred_pixel_size_fs",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_inferred_pixel_size_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_inferred_pixel_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_detector_struct_get_inferred_pixel_size_fs(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_normal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_normal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_normal" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_normal(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axis_fast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_axis_fast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axis_fast" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axis_fast(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axes_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_axes_fs",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axes_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axes_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_detector_axes_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_detector_axes_sf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_detector_axes_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_detector_axes_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_coordinates_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_coordinates_sf",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_coordinates_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_coordinates_sf" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_coordinates_sf" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_coordinates_sf(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_beam_center(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_detector_struct_set_beam_center",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_beam_center" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_detector_struct_set_beam_center" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_detector_struct_set_beam_center" "', argument " "3"" of type '" "double *""'"); 
  }
  arg3 = (double *)(argp3);
  res4 = SWIG_ConvertPtr(obj3, &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_detector_struct_set_beam_center" "', argument " "4"" of type '" "double *""'"); 
  }
  arg4 = (double *)(argp4);
  res5 = SWIG_ConvertPtr(obj4, &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cbf_detector_struct_set_beam_center" "', argument " "5"" of type '" "double *""'"); 
  }
  arg5 = (double *)(argp5);
  {
    error_status=0;
    cbf_detector_struct_set_beam_center(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_area_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_area_fs",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_area_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_area_fs" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_area_fs" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_area_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_beam_center_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_beam_center_fs",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_beam_center_fs" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_beam_center_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_inferred_pixel_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_detector_struct_get_inferred_pixel_size_sf",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_inferred_pixel_size_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_inferred_pixel_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_detector_struct_get_inferred_pixel_size_sf(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_coordinates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_coordinates",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_coordinates" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_coordinates" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_coordinates" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_coordinates(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_beam_center_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_beam_center_sf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_beam_center_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_beam_center_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_area_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_area_sf",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_area_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_area_sf" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_area_sf" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_area_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_beam_center(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_get_beam_center",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_beam_center" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_get_beam_center(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_reference_beam_center_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_set_reference_beam_center_sf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_reference_beam_center_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_reference_beam_center_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_set_beam_center_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_detector_struct_set_beam_center_sf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_set_beam_center_sf" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  {
    error_status=0;
    cbf_detector_struct_set_beam_center_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_detector_struct_get_pixel_normal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_detector_struct *arg1 = (cbf_detector_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_detector_struct_get_pixel_normal",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_detector_struct_get_pixel_normal" "', argument " "1"" of type '" "cbf_detector_struct *""'"); 
  }
  arg1 = (cbf_detector_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_detector_struct_get_pixel_normal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_detector_struct_get_pixel_normal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_detector_struct_get_pixel_normal(arg1,arg2,arg3,arg4,arg5,arg6);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *cbf_detector_struct_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_cbf_detector_struct, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_cbf_handle_struct_node_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  cbf_node *arg2 = (cbf_node *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_node_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_node_set" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cbf_node, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_node_set" "', argument " "2"" of type '" "cbf_node *""'"); 
  }
  arg2 = (cbf_node *)(argp2);
  if (arg1) (arg1)->node = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_node_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cbf_node *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_node_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_node_get" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  result = (cbf_node *) ((arg1)->node);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_node, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_row_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_row_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_row_set" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_row_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->row = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_row_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_row_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_row_get" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  result = (int) ((arg1)->row);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_search_row_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_search_row_set",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_search_row_set" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_search_row_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->search_row = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_search_row_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_search_row_get",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_search_row_get" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  result = (int) ((arg1)->search_row);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_cbf_handle_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_cbf_handle_struct")) SWIG_fail;
  {
    error_status=0;
    result = (cbf_handle_struct *)new_cbf_handle_struct();
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_handle_struct, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_cbf_handle_struct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_cbf_handle_struct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_cbf_handle_struct" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    delete_cbf_handle_struct(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_select_datablock",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_datablock" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_datablock(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_force_new_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_force_new_datablock",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_force_new_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_force_new_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_force_new_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_get_3d_image_fs_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj6, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_get_3d_image_fs_as_string" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_datablocks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_reset_datablocks",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_datablocks" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_datablocks(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_tag_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_set_tag_category",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_tag_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_tag_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_set_tag_category" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    cbf_handle_struct_set_tag_category(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_tag_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_tag_root",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_tag_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_tag_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_tag_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_row_number(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_row_number",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_row_number" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_row_number(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:cbf_handle_struct_set_image",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_image" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_image" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_bin_sizes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_bin_sizes",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_bin_sizes" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_bin_sizes(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_new_row",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_new_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_rewind_saveframe",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_saveframe(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_realarrayparameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_pixel_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_get_pixel_size_sf",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_pixel_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_pixel_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_pixel_size_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    error_status=0;
    cbf_handle_struct_get_pixel_size_sf(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_force_new_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_force_new_category",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_force_new_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_force_new_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_force_new_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_force_new_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_force_new_saveframe",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_force_new_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_force_new_saveframe" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_force_new_saveframe(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_datablocks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_count_datablocks",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_datablocks" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_datablocks(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_row",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_row" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_row(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_select_column",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_column" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_column(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_detector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  cbf_detector result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_construct_detector",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_detector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_construct_detector" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (cbf_detector)cbf_handle_struct_construct_detector(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_rewind_column",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_column(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_require_column_doublevalue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column_doublevalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode4 = SWIG_AsVal_double(obj2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_require_column_doublevalue" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_require_column_doublevalue(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_datestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  double *arg7 = (double *) 0 ;
  int *arg8 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_datestamp",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_datestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_datestamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integervalue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (int)cbf_handle_struct_get_integervalue(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_crystal_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_crystal_id",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_crystal_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_crystal_id(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_doublevalue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (double)cbf_handle_struct_get_doublevalue(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_unit_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_unit_cell",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_unit_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_unit_cell(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_unit_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_unit_cell_esd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_unit_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_unit_cell_esd(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_remove_column",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_column(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_blockitem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CBF_NODETYPE result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_rewind_blockitem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_blockitem" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (CBF_NODETYPE)cbf_handle_struct_rewind_blockitem(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_value",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_value(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_categories(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_count_categories",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_categories" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_categories(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_read_widefile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_read_widefile",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_read_widefile" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_read_widefile" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_read_widefile" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    cbf_handle_struct_read_widefile(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_wavelength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_wavelength",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_wavelength" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_wavelength" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_wavelength(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_pixel_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_pixel_size_sf",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_pixel_size_sf" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_pixel_size_sf(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_diffrn_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_diffrn_id",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_diffrn_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_diffrn_id(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_datablock",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_polarization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_polarization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_polarization" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_polarization(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_select_category",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_category" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_category(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_pixel_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_get_pixel_size_fs",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_pixel_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_pixel_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_pixel_size_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    error_status=0;
    cbf_handle_struct_get_pixel_size_fs(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_read_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_read_file",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_read_file" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_read_file" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_read_file" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    cbf_handle_struct_read_file(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_datablock_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_datablock_name",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_datablock_name" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_datablock_name(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  char *arg8 = (char *) 0 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  size_t size8 = 0 ;
  int alloc8 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:cbf_handle_struct_set_realarray_wdims",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  res8 = SWIG_AsCharPtrAndSize(obj6, &buf8, &size8, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "8"" of type '" "char *""'");
  }  
  arg8 = (char *)(buf8);
  arg9 = (int)(size8 - 1);
  ecode10 = SWIG_AsVal_int(obj7, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(obj8, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(obj9, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj10, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_realarray_wdims" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    error_status=0;
    cbf_handle_struct_set_realarray_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_reference_detector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  cbf_detector result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_construct_reference_detector",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_reference_detector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_construct_reference_detector" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (cbf_detector)cbf_handle_struct_construct_reference_detector(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_3d_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_get_real_3d_image_fs_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_real_3d_image_fs_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_real_3d_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_rewind_row",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_axis_setting(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_axis_setting",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_axis_setting" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_get_axis_setting" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_get_axis_setting(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_column",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_require_column(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_timestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_timestamp",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_timestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_timestamp(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_nextrow(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_nextrow",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_nextrow" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_nextrow" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_nextrow(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  int *arg10 = (int *) 0 ;
  int *arg11 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  char *temp6 = 0 ;
  int tempn6 ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int temp10 ;
  int res10 = SWIG_TMPOBJ ;
  int temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6; arg7 = &tempn6;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_realarrayparameters_wdims_sf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (*arg6) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg6,*arg7));
    free(*arg6);
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_reset_datablock",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_3d_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:cbf_handle_struct_set_3d_image_fs",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(obj8, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_3d_image_fs" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_3d_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_saveframename(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_saveframename",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_saveframename" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_saveframename" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_saveframename(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg2 = &temp2;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_integervalue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode3 = SWIG_AsVal_int(obj1, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_require_integervalue" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    error_status=0;
    cbf_handle_struct_require_integervalue(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integerarrayparameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_3d_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:cbf_handle_struct_set_real_3d_image_sf",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_real_3d_image_sf" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_real_3d_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_write_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_handle_struct_write_file",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_write_file" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_write_file" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_write_file" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_write_file" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_write_file" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    error_status=0;
    cbf_handle_struct_write_file(arg1,(char const *)arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_divergence(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_divergence",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_divergence" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_divergence" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_divergence" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_divergence" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_divergence(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_remove_datablock",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_elements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_count_elements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_elements" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_elements(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:cbf_handle_struct_set_image_fs",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_image_fs" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_reference_detector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  cbf_detector result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_reference_detector",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_reference_detector" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_require_reference_detector" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (cbf_detector)cbf_handle_struct_require_reference_detector(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_detector_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_next_category",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_diffrn_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_diffrn_id",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_diffrn_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_diffrn_id" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_diffrn_id(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_timestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_timestamp",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_timestamp" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_timestamp(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_orientation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  double *arg8 = (double *) 0 ;
  double *arg9 = (double *) 0 ;
  double *arg10 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  double temp8 ;
  int res8 = SWIG_TMPOBJ ;
  double temp9 ;
  int res9 = SWIG_TMPOBJ ;
  double temp10 ;
  int res10 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_orientation_matrix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_orientation_matrix" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_orientation_matrix(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_image_size_fs",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_image_size_fs(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_divergence(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_divergence",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_divergence" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_divergence(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_rewind_category",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_read_template(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_read_template",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_read_template" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_read_template" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_read_template(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_select_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_select_row",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_select_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_select_row" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_select_row(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_get_image_fs_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_image_fs_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_image_size_sf",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_image_size_sf(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_image_fs_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_handle_struct_get_real_image_fs_as_string",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_image_fs_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_get_real_image_fs_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_columns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_count_columns",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_columns" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_columns(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  char **arg10 = (char **) 0 ;
  int *arg11 = (int *) 0 ;
  int *arg12 = (int *) 0 ;
  int *arg13 = (int *) 0 ;
  int *arg14 = (int *) 0 ;
  int *arg15 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  char *temp10 = 0 ;
  int tempn10 ;
  int temp12 ;
  int res12 = SWIG_TMPOBJ ;
  int temp13 ;
  int res13 = SWIG_TMPOBJ ;
  int temp14 ;
  int res14 = SWIG_TMPOBJ ;
  int temp15 ;
  int res15 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10; arg11 = &tempn10;
  arg12 = &temp12;
  arg13 = &temp13;
  arg14 = &temp14;
  arg15 = &temp15;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integerarrayparameters_wdims",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (*arg10) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg10,*arg11));
    free(*arg10);
  }
  if (SWIG_IsTmpObj(res12)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg12)));
  } else {
    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res13)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg13)));
  } else {
    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res14)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg14)));
  } else {
    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res15)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg15)));
  } else {
    int new_flags = SWIG_IsNewObj(res15) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg15), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_gain(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_gain",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_gain" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_gain" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_gain(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_new_saveframe",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_saveframe" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_saveframe(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_polarization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_set_polarization",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_polarization" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_polarization" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_polarization" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_set_polarization(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_3d_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:cbf_handle_struct_set_real_3d_image",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_real_3d_image" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_real_3d_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_delete_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_delete_row",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_delete_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_delete_row" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_delete_row(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_column_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_column_name",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_column_name" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_column_name(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_remove_saveframe",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_saveframe(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  char *arg9 = (char *) 0 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  size_t size9 = 0 ;
  int alloc9 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:cbf_handle_struct_set_integerarray_wdims_sf",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  res9 = SWIG_AsCharPtrAndSize(obj7, &buf9, &size9, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "9"" of type '" "char *""'");
  }  
  arg9 = (char *)(buf9);
  arg10 = (int)(size9 - 1);
  ecode11 = SWIG_AsVal_int(obj8, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(obj9, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj10, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(obj11, &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cbf_handle_struct_set_integerarray_wdims_sf" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_value",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_value" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_value(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int *arg3 = (int *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_require_column_integervalue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column_integervalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode4 = SWIG_AsVal_int(obj2, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_require_column_integervalue" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    error_status=0;
    cbf_handle_struct_require_column_integervalue(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_pixel_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_pixel_size",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_pixel_size" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_pixel_size(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_next_column",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_column(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_size_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_3d_image_size_sf",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_size_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_size_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_size_sf(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  int *arg10 = (int *) 0 ;
  int *arg11 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  char *temp6 = 0 ;
  int tempn6 ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int temp10 ;
  int res10 = SWIG_TMPOBJ ;
  int temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6; arg7 = &tempn6;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_realarrayparameters_wdims_fs",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (*arg6) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg6,*arg7));
    free(*arg6);
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarray_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char **arg2 = (char **) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 = 0 ;
  int tempn2 ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2; arg3 = &tempn2;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_realarray_as_string",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarray_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarray_as_string(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg2) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg2,*arg3));
    free(*arg2);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_bin_sizes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_bin_sizes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_bin_sizes" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_bin_sizes" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_bin_sizes(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_reset_category",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_construct_goniometer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cbf_goniometer result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_construct_goniometer",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_construct_goniometer" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (cbf_goniometer)cbf_handle_struct_construct_goniometer(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_positioner_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_datablockname(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_datablockname",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_datablockname" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_datablockname" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_datablockname(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_crystal_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_crystal_id",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_crystal_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_crystal_id" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_crystal_id(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarray_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char **arg2 = (char **) 0 ;
  int *arg3 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *temp2 = 0 ;
  int tempn2 ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2; arg3 = &tempn2;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integerarray_as_string",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarray_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarray_as_string(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg2) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg2,*arg3));
    free(*arg2);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_3d_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:cbf_handle_struct_set_3d_image",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(obj8, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_3d_image" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_3d_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_dictionary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  cbf_handle arg2 = (cbf_handle) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_dictionary",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_dictionary" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_dictionary" "', argument " "2"" of type '" "cbf_handle""'"); 
  }
  arg2 = (cbf_handle)(argp2);
  {
    error_status=0;
    cbf_handle_struct_set_dictionary(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_tag_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_tag_category",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_tag_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_tag_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_find_tag_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_3d_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_get_real_3d_image_sf_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_real_3d_image_sf_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_real_3d_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_typeofvalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_typeofvalue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_typeofvalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_typeofvalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_typeofvalue(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  char *arg9 = (char *) 0 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  size_t size9 = 0 ;
  int alloc9 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:cbf_handle_struct_set_integerarray_wdims",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  res9 = SWIG_AsCharPtrAndSize(obj7, &buf9, &size9, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "9"" of type '" "char *""'");
  }  
  arg9 = (char *)(buf9);
  arg10 = (int)(size9 - 1);
  ecode11 = SWIG_AsVal_int(obj8, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(obj9, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj10, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(obj11, &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cbf_handle_struct_set_integerarray_wdims" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integration_time(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_integration_time",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integration_time" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integration_time" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_integration_time(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_axis_setting(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_axis_setting",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_axis_setting" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_axis_setting(arg1,(char const *)arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_handle_struct_get_real_image_as_string",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_get_real_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_get_3d_image_sf_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj6, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_get_3d_image_sf_as_string" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_set_real_image_fs",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_real_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_overload(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double *arg3 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_overload",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_overload" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_overload" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_overload(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_wavelength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_wavelength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_wavelength" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (double)cbf_handle_struct_get_wavelength(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_double((double)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_next_datablock",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_realarrayparameters_wdims(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  char **arg6 = (char **) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  int *arg10 = (int *) 0 ;
  int *arg11 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  char *temp6 = 0 ;
  int tempn6 ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  int temp10 ;
  int res10 = SWIG_TMPOBJ ;
  int temp11 ;
  int res11 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6; arg7 = &tempn6;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10;
  arg11 = &temp11;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_realarrayparameters_wdims",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_realarrayparameters_wdims" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_realarrayparameters_wdims(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (*arg6) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg6,*arg7));
    free(*arg6);
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res10)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg10)));
  } else {
    int new_flags = SWIG_IsNewObj(res10) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg10), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res11)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg11)));
  } else {
    int new_flags = SWIG_IsNewObj(res11) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg11), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_orientation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  double arg7 ;
  double arg8 ;
  double arg9 ;
  double arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  double val10 ;
  int ecode10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOO:cbf_handle_struct_set_orientation_matrix",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_double(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "8"" of type '" "double""'");
  } 
  arg8 = (double)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  ecode10 = SWIG_AsVal_double(obj9, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_orientation_matrix" "', argument " "10"" of type '" "double""'");
  } 
  arg10 = (double)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_orientation_matrix(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_new_category",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_gain(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_gain",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_gain" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_gain" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_gain" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_gain" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_gain(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_column",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_column" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_column(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_remove_category",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_category(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  char **arg10 = (char **) 0 ;
  int *arg11 = (int *) 0 ;
  int *arg12 = (int *) 0 ;
  int *arg13 = (int *) 0 ;
  int *arg14 = (int *) 0 ;
  int *arg15 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  char *temp10 = 0 ;
  int tempn10 ;
  int temp12 ;
  int res12 = SWIG_TMPOBJ ;
  int temp13 ;
  int res13 = SWIG_TMPOBJ ;
  int temp14 ;
  int res14 = SWIG_TMPOBJ ;
  int temp15 ;
  int res15 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10; arg11 = &tempn10;
  arg12 = &temp12;
  arg13 = &temp13;
  arg14 = &temp14;
  arg15 = &temp15;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integerarrayparameters_wdims_sf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (*arg10) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg10,*arg11));
    free(*arg10);
  }
  if (SWIG_IsTmpObj(res12)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg12)));
  } else {
    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res13)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg13)));
  } else {
    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res14)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg14)));
  } else {
    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res15)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg15)));
  } else {
    int new_flags = SWIG_IsNewObj(res15) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg15), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_pixel_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double *arg4 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_get_pixel_size",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_pixel_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_pixel_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_get_pixel_size" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  {
    error_status=0;
    cbf_handle_struct_get_pixel_size(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_set_real_image_sf",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_real_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_category",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_require_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_reciprocal_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_reciprocal_cell",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_reciprocal_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_reciprocal_cell(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_reciprocal_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  double *arg6 = (double *) 0 ;
  double *arg7 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  double temp4 ;
  int res4 = SWIG_TMPOBJ ;
  double temp5 ;
  int res5 = SWIG_TMPOBJ ;
  double temp6 ;
  int res6 = SWIG_TMPOBJ ;
  double temp7 ;
  int res7 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_reciprocal_cell_esd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_reciprocal_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_reciprocal_cell_esd(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_3d_image_size",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_size(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_tag_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_tag_root",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_tag_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_tag_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_find_tag_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_category_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_category_root",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_category_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_category_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_category_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray_wdims_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  char *arg8 = (char *) 0 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  size_t size8 = 0 ;
  int alloc8 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:cbf_handle_struct_set_realarray_wdims_sf",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  res8 = SWIG_AsCharPtrAndSize(obj6, &buf8, &size8, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "8"" of type '" "char *""'");
  }  
  arg8 = (char *)(buf8);
  arg9 = (int)(size8 - 1);
  ecode10 = SWIG_AsVal_int(obj7, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(obj8, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(obj9, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj10, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_realarray_wdims_sf" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    error_status=0;
    cbf_handle_struct_set_realarray_wdims_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integervalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_integervalue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integervalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integervalue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_integervalue(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_category_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_category_name",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_category_name" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_category_name(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_typeofvalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_typeofvalue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_typeofvalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_typeofvalue(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_set_real_image",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_image" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_image" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_image" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_image" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_image" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_image" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_image" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_real_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_get_3d_image_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj6, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_get_3d_image_as_string" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_remove_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_remove_row",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_remove_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_remove_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_overload(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_set_overload",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_overload" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_overload" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_overload" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_set_overload(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_image_size",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_size" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_size" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_image_size(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_3d_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:cbf_handle_struct_set_3d_image_sf",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(obj8, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_3d_image_sf" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    error_status=0;
    cbf_handle_struct_set_3d_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_handle_struct_get_real_image_sf_as_string",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_get_real_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_get_image_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_image_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_tag_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_set_tag_root",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_tag_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_tag_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_set_tag_root" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    cbf_handle_struct_set_tag_root(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_write_widefile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:cbf_handle_struct_write_widefile",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_write_widefile" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_write_widefile" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_write_widefile" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_write_widefile" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_write_widefile" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    error_status=0;
    cbf_handle_struct_write_widefile(arg1,(char const *)arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_count_rows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_count_rows",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_count_rows" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (unsigned int)cbf_handle_struct_count_rows(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_From_unsigned_SS_int((unsigned int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_datablock",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_require_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:cbf_handle_struct_set_integerarray",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_new_datablock",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_datablock" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_datablock(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_datestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  double arg7 ;
  int arg8 ;
  double arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  double val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:cbf_handle_struct_set_datestamp",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_double(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  ecode8 = SWIG_AsVal_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_double(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_datestamp" "', argument " "9"" of type '" "double""'");
  } 
  arg9 = (double)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_datestamp(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_next_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_next_row",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_next_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_next_row(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_category_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_set_category_root",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_category_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_category_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_set_category_root" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    cbf_handle_struct_set_category_root(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_pixel_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:cbf_handle_struct_set_pixel_size_fs",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  ecode4 = SWIG_AsVal_double(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cbf_handle_struct_set_pixel_size_fs" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    error_status=0;
    cbf_handle_struct_set_pixel_size_fs(arg1,arg2,arg3,arg4);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_insert_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_insert_row",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_insert_row" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_insert_row" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_insert_row(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_new_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_new_column",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_new_column" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_new_column" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_new_column(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_real_3d_image_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_get_real_3d_image_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_real_3d_image_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_real_3d_image_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integration_time(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integration_time",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integration_time" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integration_time(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_set_realarray",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    error_status=0;
    cbf_handle_struct_set_realarray(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_element_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_element_id",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_element_id" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_element_id" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_get_element_id(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_image_sf_as_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *temp3 = 0 ;
  int tempn3 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  
  arg3 = &temp3; arg4 = &tempn3;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:cbf_handle_struct_get_image_sf_as_string",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode5 = SWIG_AsVal_int(obj2, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(obj3, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj4, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj5, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_get_image_sf_as_string" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    error_status=0;
    cbf_handle_struct_get_image_sf_as_string(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (*arg3) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg3,*arg4));
    free(*arg3);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_3d_image_size_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_get_3d_image_size_fs",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_3d_image_size_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_get_3d_image_size_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  {
    error_status=0;
    cbf_handle_struct_get_3d_image_size_fs(arg1,arg2,arg3,arg4,arg5);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_value",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_value" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_set_value(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_current_timestamp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_current_timestamp",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_current_timestamp" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_current_timestamp" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    error_status=0;
    cbf_handle_struct_set_current_timestamp(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 = (double *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  arg2 = &temp2;
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_require_doublevalue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode3 = SWIG_AsVal_double(obj1, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_require_doublevalue" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_require_doublevalue(arg1,arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_rewind_datablock(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_rewind_datablock",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_rewind_datablock" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_rewind_datablock(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_require_column_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_require_column_value",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_require_column_value" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_require_column_value" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cbf_handle_struct_require_column_value" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_require_column_value(arg1,(char const *)arg2,(char const *)arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_dictionary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  cbf_handle result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_dictionary",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_dictionary" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    result = (cbf_handle)cbf_handle_struct_get_dictionary(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_reset_saveframe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_reset_saveframe",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_reset_saveframe" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_reset_saveframe(arg1);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_reciprocal_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_reciprocal_cell",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_reciprocal_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (obj1 == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(obj1,temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_reciprocal_cell(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_reciprocal_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_reciprocal_cell_esd",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_reciprocal_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (obj1 == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(obj1,temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_reciprocal_cell_esd(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_real_3d_image_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:cbf_handle_struct_set_real_3d_image_fs",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_real_3d_image_fs" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_real_3d_image_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_doublevalue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:cbf_handle_struct_set_doublevalue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_doublevalue" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_set_doublevalue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_doublevalue" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    error_status=0;
    cbf_handle_struct_set_doublevalue(arg1,(char const *)arg2,arg3);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_category(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_category",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_category" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_category" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    cbf_handle_struct_find_category(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_get_integerarrayparameters_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int *arg5 = (int *) 0 ;
  int *arg6 = (int *) 0 ;
  int *arg7 = (int *) 0 ;
  int *arg8 = (int *) 0 ;
  int *arg9 = (int *) 0 ;
  char **arg10 = (char **) 0 ;
  int *arg11 = (int *) 0 ;
  int *arg12 = (int *) 0 ;
  int *arg13 = (int *) 0 ;
  int *arg14 = (int *) 0 ;
  int *arg15 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int temp2 ;
  int res2 = SWIG_TMPOBJ ;
  int temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  int temp6 ;
  int res6 = SWIG_TMPOBJ ;
  int temp7 ;
  int res7 = SWIG_TMPOBJ ;
  int temp8 ;
  int res8 = SWIG_TMPOBJ ;
  int temp9 ;
  int res9 = SWIG_TMPOBJ ;
  char *temp10 = 0 ;
  int tempn10 ;
  int temp12 ;
  int res12 = SWIG_TMPOBJ ;
  int temp13 ;
  int res13 = SWIG_TMPOBJ ;
  int temp14 ;
  int res14 = SWIG_TMPOBJ ;
  int temp15 ;
  int res15 = SWIG_TMPOBJ ;
  PyObject * obj0 = 0 ;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  arg6 = &temp6;
  arg7 = &temp7;
  arg8 = &temp8;
  arg9 = &temp9;
  arg10 = &temp10; arg11 = &tempn10;
  arg12 = &temp12;
  arg13 = &temp13;
  arg14 = &temp14;
  arg15 = &temp15;
  if (!PyArg_ParseTuple(args,(char *)"O:cbf_handle_struct_get_integerarrayparameters_wdims_fs",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_get_integerarrayparameters_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    error_status=0;
    cbf_handle_struct_get_integerarrayparameters_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsTmpObj(res2)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res6)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg6)));
  } else {
    int new_flags = SWIG_IsNewObj(res6) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg6), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res7)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg7)));
  } else {
    int new_flags = SWIG_IsNewObj(res7) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg7), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res8)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg8)));
  } else {
    int new_flags = SWIG_IsNewObj(res8) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg8), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res9)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg9)));
  } else {
    int new_flags = SWIG_IsNewObj(res9) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg9), SWIGTYPE_p_int, new_flags));
  }
  if (*arg10) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_FromCharPtrAndSize(*arg10,*arg11));
    free(*arg10);
  }
  if (SWIG_IsTmpObj(res12)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg12)));
  } else {
    int new_flags = SWIG_IsNewObj(res12) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg12), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res13)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg13)));
  } else {
    int new_flags = SWIG_IsNewObj(res13) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg13), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res14)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg14)));
  } else {
    int new_flags = SWIG_IsNewObj(res14) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg14), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res15)) {
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_From_int((*arg15)));
  } else {
    int new_flags = SWIG_IsNewObj(res15) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    resultobj = SWIG_Python_AppendOutput(resultobj, SWIG_NewPointerObj((void*)(arg15), SWIGTYPE_p_int, new_flags));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_realarray_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  char *arg8 = (char *) 0 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  size_t size8 = 0 ;
  int alloc8 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOO:cbf_handle_struct_set_realarray_wdims_fs",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  res8 = SWIG_AsCharPtrAndSize(obj6, &buf8, &size8, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "8"" of type '" "char *""'");
  }  
  arg8 = (char *)(buf8);
  arg9 = (int)(size8 - 1);
  ecode10 = SWIG_AsVal_int(obj7, &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(obj8, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(obj9, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj10, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_realarray_wdims_fs" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    error_status=0;
    cbf_handle_struct_set_realarray_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc8 == SWIG_NEWOBJ) free((char*)buf8);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_find_category_root(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_find_category_root",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_find_category_root" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cbf_handle_struct_find_category_root" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    error_status=0;
    result = (char *)cbf_handle_struct_find_category_root(arg1,(char const *)arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_integerarray_wdims_fs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  char *arg9 = (char *) 0 ;
  int arg10 ;
  int arg11 ;
  int arg12 ;
  int arg13 ;
  int arg14 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  size_t size9 = 0 ;
  int alloc9 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOOOOO:cbf_handle_struct_set_integerarray_wdims_fs",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  res9 = SWIG_AsCharPtrAndSize(obj7, &buf9, &size9, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "9"" of type '" "char *""'");
  }  
  arg9 = (char *)(buf9);
  arg10 = (int)(size9 - 1);
  ecode11 = SWIG_AsVal_int(obj8, &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  ecode12 = SWIG_AsVal_int(obj9, &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "12"" of type '" "int""'");
  } 
  arg12 = (int)(val12);
  ecode13 = SWIG_AsVal_int(obj10, &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  ecode14 = SWIG_AsVal_int(obj11, &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cbf_handle_struct_set_integerarray_wdims_fs" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    error_status=0;
    cbf_handle_struct_set_integerarray_wdims_fs(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_image_sf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  size_t size4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:cbf_handle_struct_set_image_sf",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = (unsigned int)(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, &size4, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "4"" of type '" "char *""'");
  }  
  arg4 = (char *)(buf4);
  arg5 = (int)(size4 - 1);
  ecode6 = SWIG_AsVal_int(obj4, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(obj5, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(obj6, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(obj7, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cbf_handle_struct_set_image_sf" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    error_status=0;
    cbf_handle_struct_set_image_sf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_unit_cell(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_unit_cell",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_unit_cell" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (obj1 == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(obj1,temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_unit_cell(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cbf_handle_struct_set_unit_cell_esd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  cbf_handle_struct *arg1 = (cbf_handle_struct *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double temp2[6] ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:cbf_handle_struct_set_unit_cell_esd",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_cbf_handle_struct, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cbf_handle_struct_set_unit_cell_esd" "', argument " "1"" of type '" "cbf_handle_struct *""'"); 
  }
  arg1 = (cbf_handle_struct *)(argp1);
  {
    if (obj1 == Py_None) arg2 = NULL;
    else 
    if (!convert_darray(obj1,temp2,6)) {
      return NULL;
    }
    arg2 = &temp2[0];
  }
  {
    error_status=0;
    cbf_handle_struct_set_unit_cell_esd(arg1,arg2);
    if (error_status){
      get_error_message();
      PyErr_SetString(PyExc_Exception,error_message);
      return NULL;
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *cbf_handle_struct_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_cbf_handle_struct, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"new_doubleArray", _wrap_new_doubleArray, METH_VARARGS, NULL},
	 { (char *)"delete_doubleArray", _wrap_delete_doubleArray, METH_VARARGS, NULL},
	 { (char *)"doubleArray___getitem__", _wrap_doubleArray___getitem__, METH_VARARGS, NULL},
	 { (char *)"doubleArray___setitem__", _wrap_doubleArray___setitem__, METH_VARARGS, NULL},
	 { (char *)"doubleArray_cast", _wrap_doubleArray_cast, METH_VARARGS, NULL},
	 { (char *)"doubleArray_frompointer", _wrap_doubleArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"doubleArray_swigregister", doubleArray_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_intArray", _wrap_new_intArray, METH_VARARGS, NULL},
	 { (char *)"delete_intArray", _wrap_delete_intArray, METH_VARARGS, NULL},
	 { (char *)"intArray___getitem__", _wrap_intArray___getitem__, METH_VARARGS, NULL},
	 { (char *)"intArray___setitem__", _wrap_intArray___setitem__, METH_VARARGS, NULL},
	 { (char *)"intArray_cast", _wrap_intArray_cast, METH_VARARGS, NULL},
	 { (char *)"intArray_frompointer", _wrap_intArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"intArray_swigregister", intArray_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_shortArray", _wrap_new_shortArray, METH_VARARGS, NULL},
	 { (char *)"delete_shortArray", _wrap_delete_shortArray, METH_VARARGS, NULL},
	 { (char *)"shortArray___getitem__", _wrap_shortArray___getitem__, METH_VARARGS, NULL},
	 { (char *)"shortArray___setitem__", _wrap_shortArray___setitem__, METH_VARARGS, NULL},
	 { (char *)"shortArray_cast", _wrap_shortArray_cast, METH_VARARGS, NULL},
	 { (char *)"shortArray_frompointer", _wrap_shortArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"shortArray_swigregister", shortArray_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_longArray", _wrap_new_longArray, METH_VARARGS, NULL},
	 { (char *)"delete_longArray", _wrap_delete_longArray, METH_VARARGS, NULL},
	 { (char *)"longArray___getitem__", _wrap_longArray___getitem__, METH_VARARGS, NULL},
	 { (char *)"longArray___setitem__", _wrap_longArray___setitem__, METH_VARARGS, NULL},
	 { (char *)"longArray_cast", _wrap_longArray_cast, METH_VARARGS, NULL},
	 { (char *)"longArray_frompointer", _wrap_longArray_frompointer, METH_VARARGS, NULL},
	 { (char *)"longArray_swigregister", longArray_swigregister, METH_VARARGS, NULL},
	 { (char *)"get_local_integer_byte_order", _wrap_get_local_integer_byte_order, METH_VARARGS, (char *)"\n"
		"Returns : char **bo,int *bolen\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_local_integer_byte_order (char ** byte_order);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_local_integer_byte_order returns the byte order of integers \n"
		"on the machine on which the API is being run in the form of a \n"
		"character string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_byte_order returns the byte order of reals on the \n"
		"machine on which the API is being run in the form of a character \n"
		"string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_format returns the format of floats on the machine \n"
		"on which the API is being run in the form of a character string \n"
		"returned as the value pointed to by real_format. The strings returned \n"
		"must not be modified in any way.\n"
		"The values returned in byte_order may be the strings  \"little_endian \n"
		"\" or  \"big-endian \". The values returned in real_format may be the \n"
		"strings  \"ieee 754-1985 \" or  \"other \". Additional values may be \n"
		"returned by future versions of the API.\n"
		"ARGUMENTS\n"
		"byte_order    pointer to the returned string real_format   pointer to \n"
		"the returned string\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"compute_cell_volume", _wrap_compute_cell_volume, METH_VARARGS, (char *)"\n"
		"Returns : Float volume\n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_compute_cell_volume ( double cell[6], double *volume );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_compute_cell_volume sets *volume to point to the volume of the \n"
		"unit cell computed from the double values in cell[0:2] for the cell \n"
		"edge lengths a, b and c in AAngstroms and the double values given in \n"
		"cell[3:5] for the cell angles a, b and g in degrees.\n"
		"ARGUMENTS\n"
		"cell     Pointer to the array of 6 doubles giving the cell \n"
		"parameters. volume   Pointer to the doubles for cell volume.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"get_local_real_format", _wrap_get_local_real_format, METH_VARARGS, (char *)"\n"
		"Returns : char **rf,int *rflen\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_local_real_format (char ** real_format );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_local_integer_byte_order returns the byte order of integers \n"
		"on the machine on which the API is being run in the form of a \n"
		"character string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_byte_order returns the byte order of reals on the \n"
		"machine on which the API is being run in the form of a character \n"
		"string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_format returns the format of floats on the machine \n"
		"on which the API is being run in the form of a character string \n"
		"returned as the value pointed to by real_format. The strings returned \n"
		"must not be modified in any way.\n"
		"The values returned in byte_order may be the strings  \"little_endian \n"
		"\" or  \"big-endian \". The values returned in real_format may be the \n"
		"strings  \"ieee 754-1985 \" or  \"other \". Additional values may be \n"
		"returned by future versions of the API.\n"
		"ARGUMENTS\n"
		"byte_order    pointer to the returned string real_format   pointer to \n"
		"the returned string\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"get_local_real_byte_order", _wrap_get_local_real_byte_order, METH_VARARGS, (char *)"\n"
		"Returns : char **bo,int *bolen\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_local_real_byte_order (char ** byte_order);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_local_integer_byte_order returns the byte order of integers \n"
		"on the machine on which the API is being run in the form of a \n"
		"character string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_byte_order returns the byte order of reals on the \n"
		"machine on which the API is being run in the form of a character \n"
		"string returned as the value pointed to by byte_order. \n"
		"cbf_get_local_real_format returns the format of floats on the machine \n"
		"on which the API is being run in the form of a character string \n"
		"returned as the value pointed to by real_format. The strings returned \n"
		"must not be modified in any way.\n"
		"The values returned in byte_order may be the strings  \"little_endian \n"
		"\" or  \"big-endian \". The values returned in real_format may be the \n"
		"strings  \"ieee 754-1985 \" or  \"other \". Additional values may be \n"
		"returned by future versions of the API.\n"
		"ARGUMENTS\n"
		"byte_order    pointer to the returned string real_format   pointer to \n"
		"the returned string\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"compute_reciprocal_cell", _wrap_compute_reciprocal_cell, METH_VARARGS, (char *)"\n"
		"Returns : Float astar,Float bstar,Float cstar,Float alphastar,Float betastar,\n"
		"          Float gammastar\n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_compute_reciprocal_cell ( double cell[6],\n"
		"                 double rcell[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_compute_reciprocal_cell sets rcell to point to the array of \n"
		"reciprocal cell parameters computed from the double values cell[0:2] \n"
		"giving the cell edge lengths a, b and c in AAngstroms, and the double \n"
		"values cell[3:5] giving the cell angles a, b and g in degrees. The \n"
		"double values rcell[0:2] will be set to the reciprocal cell lengths \n"
		"a*, b* and c* in AAngstroms-1 and the double values rcell[3:5] will \n"
		"be set to the reciprocal cell angles a*, b* and g* in degrees.\n"
		"ARGUMENTS\n"
		"cell     Pointer to the array of 6 doubles giving the cell \n"
		"parameters. rcell    Pointer to the destination array of 6 doubles \n"
		"giving the reciprocal cell parameters. volume   Pointer to the \n"
		"doubles for cell volume.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_positioner_struct_matrix_set", _wrap_cbf_positioner_struct_matrix_set, METH_VARARGS, (char *)"cbf_positioner_struct_matrix_set(cbf_positioner_struct self, double matrix)"},
	 { (char *)"cbf_positioner_struct_matrix_get", _wrap_cbf_positioner_struct_matrix_get, METH_VARARGS, (char *)"cbf_positioner_struct_matrix_get(cbf_positioner_struct self) -> double"},
	 { (char *)"cbf_positioner_struct_axis_set", _wrap_cbf_positioner_struct_axis_set, METH_VARARGS, (char *)"cbf_positioner_struct_axis_set(cbf_positioner_struct self, cbf_axis_struct axis)"},
	 { (char *)"cbf_positioner_struct_axis_get", _wrap_cbf_positioner_struct_axis_get, METH_VARARGS, (char *)"cbf_positioner_struct_axis_get(cbf_positioner_struct self) -> cbf_axis_struct"},
	 { (char *)"cbf_positioner_struct_axes_set", _wrap_cbf_positioner_struct_axes_set, METH_VARARGS, (char *)"cbf_positioner_struct_axes_set(cbf_positioner_struct self, size_t axes)"},
	 { (char *)"cbf_positioner_struct_axes_get", _wrap_cbf_positioner_struct_axes_get, METH_VARARGS, (char *)"cbf_positioner_struct_axes_get(cbf_positioner_struct self) -> size_t"},
	 { (char *)"cbf_positioner_struct_matrix_is_valid_set", _wrap_cbf_positioner_struct_matrix_is_valid_set, METH_VARARGS, (char *)"cbf_positioner_struct_matrix_is_valid_set(cbf_positioner_struct self, int matrix_is_valid)"},
	 { (char *)"cbf_positioner_struct_matrix_is_valid_get", _wrap_cbf_positioner_struct_matrix_is_valid_get, METH_VARARGS, (char *)"cbf_positioner_struct_matrix_is_valid_get(cbf_positioner_struct self) -> int"},
	 { (char *)"cbf_positioner_struct_axes_are_connected_set", _wrap_cbf_positioner_struct_axes_are_connected_set, METH_VARARGS, (char *)"cbf_positioner_struct_axes_are_connected_set(cbf_positioner_struct self, int axes_are_connected)"},
	 { (char *)"cbf_positioner_struct_axes_are_connected_get", _wrap_cbf_positioner_struct_axes_are_connected_get, METH_VARARGS, (char *)"cbf_positioner_struct_axes_are_connected_get(cbf_positioner_struct self) -> int"},
	 { (char *)"new_cbf_positioner_struct", _wrap_new_cbf_positioner_struct, METH_VARARGS, (char *)"new_cbf_positioner_struct() -> cbf_positioner_struct"},
	 { (char *)"delete_cbf_positioner_struct", _wrap_delete_cbf_positioner_struct, METH_VARARGS, (char *)"delete_cbf_positioner_struct(cbf_positioner_struct self)"},
	 { (char *)"cbf_positioner_struct_get_rotation_range", _wrap_cbf_positioner_struct_get_rotation_range, METH_VARARGS, (char *)"\n"
		"Returns : Float start,Float increment\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_rotation_range (cbf_goniometer goniometer,\n"
		"                 unsigned int      reserved, double *start, double *increment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_rotation_range sets *start and *increment to the \n"
		"corresponding values of the goniometer rotation axis used for the \n"
		"exposure.\n"
		"Either of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer   Goniometer handle. reserved     Unused. Any value other \n"
		"than 0 is invalid. start        Pointer to the destination start \n"
		"value. increment    Pointer to the destination increment value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_positioner_struct_rotate_vector", _wrap_cbf_positioner_struct_rotate_vector, METH_VARARGS, (char *)"\n"
		"Returns : double final1,double final2,double final3\n"
		"*args   : double ratio,double initial1,double initial2,double initial3\n"
		"\n"
		"C prototype: int cbf_rotate_vector (cbf_goniometer goniometer,\n"
		"                 unsigned int reserved,      double ratio, double initial1,\n"
		"                 double initial2, double initial3, double      *final1,\n"
		"                 double *final2, double *final3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rotate_vector sets *final1, *final2, and *final3 to the 3 \n"
		"components of the of the vector (initial1, initial2, initial3) after \n"
		"reorientation by applying the goniometer rotations. The value ratio \n"
		"specif ies the goniometer setting and varies from 0.0 at the \n"
		"beginning of the exposure to 1.0 at the end, irrespective of the \n"
		"actual rotation range.\n"
		"Any of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer   Goniometer handle. reserved     Unused. Any value other \n"
		"than 0 is invalid. ratio        Goniometer setting. 0 = beginning of \n"
		"exposure, 1 = end. initial1     x component of the initial vector. \n"
		"initial2     y component of the initial vector. initial3     z \n"
		"component of the initial vector. vector1      Pointer to the \n"
		"destination x component of the final vector. vector2      Pointer to \n"
		"the destination y component of the final vector. vector3      Pointer \n"
		"to the destination z component of the final vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_positioner_struct_get_reciprocal", _wrap_cbf_positioner_struct_get_reciprocal, METH_VARARGS, (char *)"\n"
		"Returns : double reciprocal1,double reciprocal2,double reciprocal3\n"
		"*args   : double ratio,double wavelength,double real1,double real2,double real3\n"
		"\n"
		"C prototype: int cbf_get_reciprocal (cbf_goniometer goniometer,\n"
		"                 unsigned int      reserved, double ratio, double wavelength,\n"
		"                 double real1, double real2,      double real3,\n"
		"                 double *reciprocal1, double *reciprocal2,\n"
		"                 double      *reciprocal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_reciprocal sets *reciprocal1, * reciprocal2, and * \n"
		"reciprocal3 to the 3 components of the of the reciprocal-space vector \n"
		"corresponding to the real-space vector (real1, real2, real3). The \n"
		"reciprocal-space vector is oriented to correspond to the goniometer \n"
		"setting with all axes at 0. The value wavelength is the wavlength in \n"
		"AA and the value ratio specifies the current goniometer setting and \n"
		"varies from 0.0 at the beginning of the exposur e to 1.0 at the end, \n"
		"irrespective of the actual rotation range.\n"
		"Any of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer    Goniometer handle. reserved      Unused. Any value \n"
		"other than 0 is invalid. ratio         Goniometer setting. 0 = \n"
		"beginning of exposure, 1 = end. wavelength    Wavelength in AA. real1 \n"
		"        x component of the real-space vector. real2         y \n"
		"component of the real-space vector. real3         z component of the \n"
		"real-space vector. reciprocal1   Pointer to the destination x \n"
		"component of the reciprocal-space vector. reciprocal2   Pointer to \n"
		"the destination y component of the reciprocal-space vector. \n"
		"reciprocal3   Pointer to the destination z component of the \n"
		"reciprocal-space vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_positioner_struct_get_rotation_axis", _wrap_cbf_positioner_struct_get_rotation_axis, METH_VARARGS, (char *)"\n"
		"Returns : double vector1,double vector2,double vector3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_rotation_axis (cbf_goniometer goniometer,\n"
		"                 unsigned int      reserved, double *vector1, double *vector2,\n"
		"                 double *vector3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_rotation_axis sets *vector1, *vector2, and *vector3 to the 3 \n"
		"components of the goniometer rotation axis used for the exposure.\n"
		"Any of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"goniometer   Goniometer handle. reserved     Unused. Any value other \n"
		"than 0 is invalid. vector1      Pointer to the destination x \n"
		"component of the rotation axis. vector2      Pointer to the \n"
		"destination y component of the rotation axis. vector3      Pointer to \n"
		"the destination z component of the rotation axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_positioner_struct_swigregister", cbf_positioner_struct_swigregister, METH_VARARGS, NULL},
	 { (char *)"cbf_detector_struct_positioner_set", _wrap_cbf_detector_struct_positioner_set, METH_VARARGS, (char *)"cbf_detector_struct_positioner_set(cbf_detector_struct self, cbf_positioner positioner)"},
	 { (char *)"cbf_detector_struct_positioner_get", _wrap_cbf_detector_struct_positioner_get, METH_VARARGS, (char *)"cbf_detector_struct_positioner_get(cbf_detector_struct self) -> cbf_positioner"},
	 { (char *)"cbf_detector_struct_displacement_set", _wrap_cbf_detector_struct_displacement_set, METH_VARARGS, (char *)"cbf_detector_struct_displacement_set(cbf_detector_struct self, double displacement)"},
	 { (char *)"cbf_detector_struct_displacement_get", _wrap_cbf_detector_struct_displacement_get, METH_VARARGS, (char *)"cbf_detector_struct_displacement_get(cbf_detector_struct self) -> double"},
	 { (char *)"cbf_detector_struct_increment_set", _wrap_cbf_detector_struct_increment_set, METH_VARARGS, (char *)"cbf_detector_struct_increment_set(cbf_detector_struct self, double increment)"},
	 { (char *)"cbf_detector_struct_increment_get", _wrap_cbf_detector_struct_increment_get, METH_VARARGS, (char *)"cbf_detector_struct_increment_get(cbf_detector_struct self) -> double"},
	 { (char *)"cbf_detector_struct_axes_set", _wrap_cbf_detector_struct_axes_set, METH_VARARGS, (char *)"cbf_detector_struct_axes_set(cbf_detector_struct self, size_t axes)"},
	 { (char *)"cbf_detector_struct_axes_get", _wrap_cbf_detector_struct_axes_get, METH_VARARGS, (char *)"cbf_detector_struct_axes_get(cbf_detector_struct self) -> size_t"},
	 { (char *)"cbf_detector_struct_index_set", _wrap_cbf_detector_struct_index_set, METH_VARARGS, (char *)"cbf_detector_struct_index_set(cbf_detector_struct self, size_t index)"},
	 { (char *)"cbf_detector_struct_index_get", _wrap_cbf_detector_struct_index_get, METH_VARARGS, (char *)"cbf_detector_struct_index_get(cbf_detector_struct self) -> size_t"},
	 { (char *)"new_cbf_detector_struct", _wrap_new_cbf_detector_struct, METH_VARARGS, (char *)"new_cbf_detector_struct() -> cbf_detector_struct"},
	 { (char *)"delete_cbf_detector_struct", _wrap_delete_cbf_detector_struct, METH_VARARGS, (char *)"delete_cbf_detector_struct(cbf_detector_struct self)"},
	 { (char *)"cbf_detector_struct_set_reference_beam_center_fs", _wrap_cbf_detector_struct_set_reference_beam_center_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double indexfast,double indexslow,double centerfast,double centerslow\n"
		"\n"
		"C prototype: int cbf_set_reference_beam_center_fs (cbf_detector detector,\n"
		"                 double      *indexfast, double *indexslow, double *centerfast,\n"
		"                 double *centerslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_coordinates_fs", _wrap_cbf_detector_struct_get_pixel_coordinates_fs, METH_VARARGS, (char *)"\n"
		"Returns : double coordinate1,double coordinate2,double coordinate3\n"
		"*args   : double indexfast,double indexslow\n"
		"\n"
		"C prototype: int cbf_get_pixel_coordinates_fs (cbf_detector detector,\n"
		"                 double      indexfast, double indexslow, double *coordinate1,\n"
		"                 double *coordinate2,      double *coordinate3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_coordinates, cbf_get_pixel_coordinates_fs and \n"
		"cbf_get_pixel_coordinates_sf ses *coordinate1, *coordinate2, and \n"
		"*coordinate3 to the vector position of pixel (indexfast, indexslow) \n"
		"on the detector surface. If indexslow and indexfast are integers then \n"
		"the coordinates correspond to the center of a pixel.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. indexslow     Slow index. indexfast    \n"
		" Fast index. coordinate1   Pointer to the destination x component. \n"
		"coordinate2   Pointer to the destination y component. coordinate3   \n"
		"Pointer to the destination z component.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_set_beam_center_fs", _wrap_cbf_detector_struct_set_beam_center_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double indexfast,double indexslow,double centerfast,double centerslow\n"
		"\n"
		"C prototype: int cbf_set_beam_center_fs (cbf_detector detector,\n"
		"                 double *indexfast,      double *indexslow, double *centerfast,\n"
		"                 double *centerslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_inferred_pixel_size", _wrap_cbf_detector_struct_get_inferred_pixel_size, METH_VARARGS, (char *)"\n"
		"Returns : Float pixel size\n"
		"*args   : Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_inferred_pixel_size (cbf_detector detector,\n"
		"                 int axis_number,      double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_inferred_pixel_size, cbf_get_inferred_pixel_size_sf set \n"
		"*psize to point to the double value in millimeters of the pixel size \n"
		"for the axis axis_number value. The slow index is treated as axis 1 \n"
		"and the next faster index is treated as axis 2. \n"
		"cbf_get_inferred_pixel_size_fs sets *psize to point to the double \n"
		"value in millimeters of the pixel size for the axis axis_number \n"
		"value. The fast index is treated as axis 1 and the next slower index \n"
		"is treated as axis 2.\n"
		"If the axis number is negative, the axes are used in the reverse \n"
		"order so that an axis_number of -1 indicates the fast axes in a call \n"
		"to cbf_get_inferred_pixel_size or cbf_get_inferred_pixel_size_sf and \n"
		"indicates the fast axis in a call to cbf_get_inferred_pixel_size_fs.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. axis_number   The number of the axis. \n"
		"area          Pointer to the destination pizel size in mm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_area", _wrap_cbf_detector_struct_get_pixel_area, METH_VARARGS, (char *)"\n"
		"Returns : double area,double projected_area\n"
		"*args   : double index1,double index2\n"
		"\n"
		"C prototype: int cbf_get_pixel_area (cbf_detector detector, double indexslow,\n"
		"                 double      indexfast, double *area, double *projected_area);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_area, cbf_get_pixel_area_fs and cbf_get_pixel_area_sf \n"
		"set *area to the area of the pixel at (indexfast, indexslow) on the \n"
		"detector surface and *projected_area to the apparent area of the \n"
		"pixel as viewed from the sample position, with indexslow being the \n"
		"slow axis and indexfast being the fast axis.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector         Detector handle. indexfast        Fast index. \n"
		"indexslow        Slow index. area             Pointer to the \n"
		"destination area in mm2. projected_area   Pointer to the destination \n"
		"apparent area in mm2.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_normal_fs", _wrap_cbf_detector_struct_get_pixel_normal_fs, METH_VARARGS, (char *)"\n"
		"Returns : double normal1,double normal2,double normal3\n"
		"*args   : double indexfast,double indexslow\n"
		"\n"
		"C prototype: int cbf_get_pixel_normal_fs (cbf_detector detector,\n"
		"                 double indexfast,      double indexslow, double *normal1,\n"
		"                 double *normal2, double *normal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_normal, cbf_get_pixel_normal_fs and \n"
		"cbf_get_pixel_normal_sf set *normal1, *normal2, and *normal3 to the 3 \n"
		"components of the of the normal vector to the pixel at (indexfast, \n"
		"indexslow). The vector is normalized.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. indexslow   Slow index. indexfast   Fast \n"
		"index. normal1     Pointer to the destination x component of the \n"
		"normal vector. normal2     Pointer to the destination y component of \n"
		"the normal vector. normal3     Pointer to the destination z component \n"
		"of the normal vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_detector_axes", _wrap_cbf_detector_struct_get_detector_axes, METH_VARARGS, (char *)"\n"
		"Returns : double slowaxis1,double slowaxis2,double slowaxis3,double fastaxis1,\n"
		"          double fastaxis2,double fastaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axes (cbf_detector detector,\n"
		"                 double *slowaxis1,      double *slowaxis2, double *slowaxis3,\n"
		"                 double *fastaxis1, double      *fastaxis2, double *fastaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_set_reference_beam_center", _wrap_cbf_detector_struct_set_reference_beam_center, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_reference_beam_center (cbf_detector detector,\n"
		"                 double      *indexslow, double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_detector_axis_slow", _wrap_cbf_detector_struct_get_detector_axis_slow, METH_VARARGS, (char *)"\n"
		"Returns : double slowaxis1,double slowaxis2,double slowaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axis_slow (cbf_detector detector,\n"
		"                 double      *slowaxis1, double *slowaxis2, double *slowaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_detector_distance", _wrap_cbf_detector_struct_get_detector_distance, METH_VARARGS, (char *)"\n"
		"Returns : double distance\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_distance (cbf_detector detector,\n"
		"                 double *distance);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_distance sets *distance to the nearest distance from \n"
		"the sample position to the detector plane.\n"
		"ARGUMENTS\n"
		"detector   Detector handle. distance   Pointer to the destination \n"
		"distance.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_inferred_pixel_size_fs", _wrap_cbf_detector_struct_get_inferred_pixel_size_fs, METH_VARARGS, (char *)"\n"
		"Returns : Float pixel size\n"
		"*args   : Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_inferred_pixel_size_fs(cbf_detector detector,\n"
		"                 int      axis_number, double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_inferred_pixel_size, cbf_get_inferred_pixel_size_sf set \n"
		"*psize to point to the double value in millimeters of the pixel size \n"
		"for the axis axis_number value. The slow index is treated as axis 1 \n"
		"and the next faster index is treated as axis 2. \n"
		"cbf_get_inferred_pixel_size_fs sets *psize to point to the double \n"
		"value in millimeters of the pixel size for the axis axis_number \n"
		"value. The fast index is treated as axis 1 and the next slower index \n"
		"is treated as axis 2.\n"
		"If the axis number is negative, the axes are used in the reverse \n"
		"order so that an axis_number of -1 indicates the fast axes in a call \n"
		"to cbf_get_inferred_pixel_size or cbf_get_inferred_pixel_size_sf and \n"
		"indicates the fast axis in a call to cbf_get_inferred_pixel_size_fs.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. axis_number   The number of the axis. \n"
		"area          Pointer to the destination pizel size in mm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_detector_normal", _wrap_cbf_detector_struct_get_detector_normal, METH_VARARGS, (char *)"\n"
		"Returns : double normal1,double normal2,double normal3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_normal (cbf_detector detector,\n"
		"                 double *normal1,      double *normal2, double *normal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_normal sets *normal1, *normal2, and *normal3 to the \n"
		"3 components of the of the normal vector to the detector plane. The \n"
		"vector is normalized.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector   Detector handle. normal1    Pointer to the destination x \n"
		"component of the normal vector. normal2    Pointer to the destination \n"
		"y component of the normal vector. normal3    Pointer to the \n"
		"destination z component of the normal vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_detector_axis_fast", _wrap_cbf_detector_struct_get_detector_axis_fast, METH_VARARGS, (char *)"\n"
		"Returns : double fastaxis1,double fastaxis2,double fastaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axis_fast (cbf_detector detector,\n"
		"                 double      *fastaxis1, double *fastaxis2, double *fastaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_detector_axes_fs", _wrap_cbf_detector_struct_get_detector_axes_fs, METH_VARARGS, (char *)"cbf_detector_struct_get_detector_axes_fs(cbf_detector_struct self)"},
	 { (char *)"cbf_detector_struct_get_detector_axes_sf", _wrap_cbf_detector_struct_get_detector_axes_sf, METH_VARARGS, (char *)"\n"
		"Returns : double slowaxis1,double slowaxis2,double slowaxis3,double fastaxis1,\n"
		"          double fastaxis2,double fastaxis3\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_detector_axes_sf (cbf_detector detector,\n"
		"                 double *slowaxis1,      double *slowaxis2, double *slowaxis3,\n"
		"                 double *fastaxis1, double      *fastaxis2, double *fastaxis3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_axis_slow sets *slowaxis1, *slowaxis2, and \n"
		"*slowaxis3 to the 3 components of the slow axis of the specified \n"
		"detector at the current settings of all axes. \n"
		"cbf_get_detector_axis_slow sets *fastaxis1, *fastaxis2, and \n"
		"*fastaxis3 to the 3 components of the fast axis of the specified \n"
		"detector at the current settings of all axes. cbf_get_detector_axes, \n"
		"cbf_get_detector_axes_fs and int cbf_get_detector_axes_sf set \n"
		"*slowaxis1, *slowaxis2, and *slowaxis3 to the 3 components of the \n"
		"slow axis and *fastaxis1, *fastaxis2, and *fastaxis3 to the 3 \n"
		"components of the fast axis of the specified detector at the current \n"
		"settings of all axes.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. slowaxis1   Pointer to the destination x \n"
		"component of the slow axis vector. slowaxis2   Pointer to the \n"
		"destination y component of the slow axis vector. slowaxis3   Pointer \n"
		"to the destination z component of the slow axis vector. fastaxis1   \n"
		"Pointer to the destination x component of the fast axis vector. \n"
		"fastaxis2   Pointer to the destination y component of the fast axis \n"
		"vector. fastaxis3   Pointer to the destination z component of the \n"
		"fast axis vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_coordinates_sf", _wrap_cbf_detector_struct_get_pixel_coordinates_sf, METH_VARARGS, (char *)"\n"
		"Returns : double coordinate1,double coordinate2,double coordinate3\n"
		"*args   : double indexslow,double indexfast\n"
		"\n"
		"C prototype: int cbf_get_pixel_coordinates_sf (cbf_detector detector,\n"
		"                 double      indexslow, double indexfast, double *coordinate1,\n"
		"                 double *coordinate2,      double *coordinate3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_coordinates, cbf_get_pixel_coordinates_fs and \n"
		"cbf_get_pixel_coordinates_sf ses *coordinate1, *coordinate2, and \n"
		"*coordinate3 to the vector position of pixel (indexfast, indexslow) \n"
		"on the detector surface. If indexslow and indexfast are integers then \n"
		"the coordinates correspond to the center of a pixel.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. indexslow     Slow index. indexfast    \n"
		" Fast index. coordinate1   Pointer to the destination x component. \n"
		"coordinate2   Pointer to the destination y component. coordinate3   \n"
		"Pointer to the destination z component.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_set_beam_center", _wrap_cbf_detector_struct_set_beam_center, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_beam_center (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_area_fs", _wrap_cbf_detector_struct_get_pixel_area_fs, METH_VARARGS, (char *)"\n"
		"Returns : double area,double projected_area\n"
		"*args   : double indexfast,double indexslow\n"
		"\n"
		"C prototype: int cbf_get_pixel_area_fs(cbf_detector detector,\n"
		"                 double indexfast,      double indexslow, double *area,\n"
		"                 double *projected_area);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_area, cbf_get_pixel_area_fs and cbf_get_pixel_area_sf \n"
		"set *area to the area of the pixel at (indexfast, indexslow) on the \n"
		"detector surface and *projected_area to the apparent area of the \n"
		"pixel as viewed from the sample position, with indexslow being the \n"
		"slow axis and indexfast being the fast axis.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector         Detector handle. indexfast        Fast index. \n"
		"indexslow        Slow index. area             Pointer to the \n"
		"destination area in mm2. projected_area   Pointer to the destination \n"
		"apparent area in mm2.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_beam_center_fs", _wrap_cbf_detector_struct_get_beam_center_fs, METH_VARARGS, (char *)"\n"
		"Returns : double indexfast,double indexslow,double centerfast,double centerslow\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_beam_center_fs (cbf_detector detector,\n"
		"                 double *indexfast,      double *indexslow, double *centerfast,\n"
		"                 double *centerslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_inferred_pixel_size_sf", _wrap_cbf_detector_struct_get_inferred_pixel_size_sf, METH_VARARGS, (char *)"\n"
		"Returns : Float pixel size\n"
		"*args   : Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_inferred_pixel_size_sf(cbf_detector detector,\n"
		"                 int      axis_number, double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_inferred_pixel_size, cbf_get_inferred_pixel_size_sf set \n"
		"*psize to point to the double value in millimeters of the pixel size \n"
		"for the axis axis_number value. The slow index is treated as axis 1 \n"
		"and the next faster index is treated as axis 2. \n"
		"cbf_get_inferred_pixel_size_fs sets *psize to point to the double \n"
		"value in millimeters of the pixel size for the axis axis_number \n"
		"value. The fast index is treated as axis 1 and the next slower index \n"
		"is treated as axis 2.\n"
		"If the axis number is negative, the axes are used in the reverse \n"
		"order so that an axis_number of -1 indicates the fast axes in a call \n"
		"to cbf_get_inferred_pixel_size or cbf_get_inferred_pixel_size_sf and \n"
		"indicates the fast axis in a call to cbf_get_inferred_pixel_size_fs.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. axis_number   The number of the axis. \n"
		"area          Pointer to the destination pizel size in mm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_coordinates", _wrap_cbf_detector_struct_get_pixel_coordinates, METH_VARARGS, (char *)"\n"
		"Returns : double coordinate1,double coordinate2,double coordinate3\n"
		"*args   : double index1,double index2\n"
		"\n"
		"C prototype: int cbf_get_pixel_coordinates (cbf_detector detector,\n"
		"                 double indexslow,      double indexfast, double *coordinate1,\n"
		"                 double *coordinate2, double      *coordinate3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_coordinates, cbf_get_pixel_coordinates_fs and \n"
		"cbf_get_pixel_coordinates_sf ses *coordinate1, *coordinate2, and \n"
		"*coordinate3 to the vector position of pixel (indexfast, indexslow) \n"
		"on the detector surface. If indexslow and indexfast are integers then \n"
		"the coordinates correspond to the center of a pixel.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector      Detector handle. indexslow     Slow index. indexfast    \n"
		" Fast index. coordinate1   Pointer to the destination x component. \n"
		"coordinate2   Pointer to the destination y component. coordinate3   \n"
		"Pointer to the destination z component.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_beam_center_sf", _wrap_cbf_detector_struct_get_beam_center_sf, METH_VARARGS, (char *)"\n"
		"Returns : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_beam_center_sf (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_area_sf", _wrap_cbf_detector_struct_get_pixel_area_sf, METH_VARARGS, (char *)"\n"
		"Returns : double area,double projected_area\n"
		"*args   : double indexslow,double indexfast\n"
		"\n"
		"C prototype: int cbf_get_pixel_area_sf(cbf_detector detector,\n"
		"                 double indexslow,      double indexfast, double *area,\n"
		"                 double *projected_area);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_area, cbf_get_pixel_area_fs and cbf_get_pixel_area_sf \n"
		"set *area to the area of the pixel at (indexfast, indexslow) on the \n"
		"detector surface and *projected_area to the apparent area of the \n"
		"pixel as viewed from the sample position, with indexslow being the \n"
		"slow axis and indexfast being the fast axis.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector         Detector handle. indexfast        Fast index. \n"
		"indexslow        Slow index. area             Pointer to the \n"
		"destination area in mm2. projected_area   Pointer to the destination \n"
		"apparent area in mm2.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_beam_center", _wrap_cbf_detector_struct_get_beam_center, METH_VARARGS, (char *)"\n"
		"Returns : double index1,double index2,double center1,double center2\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_beam_center (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_set_reference_beam_center_sf", _wrap_cbf_detector_struct_set_reference_beam_center_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_reference_beam_center_sf (cbf_detector detector,\n"
		"                 double      *indexslow, double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_set_beam_center_sf", _wrap_cbf_detector_struct_set_beam_center_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double indexslow,double indexfast,double centerslow,double centerfast\n"
		"\n"
		"C prototype: int cbf_set_beam_center_sf (cbf_detector detector,\n"
		"                 double *indexslow,      double *indexfast, double *centerslow,\n"
		"                 double *centerfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_beam_center sets *centerfast and *centerslow to the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector and *indexfast and \n"
		"*indexslow to the corresponding indices. cbf_set_beam_center sets the \n"
		"offsets in the axis category for the detector element axis with \n"
		"precedence 1 to place the beam center at the position given in mm by \n"
		"*centerfast and *centerslow as the displacements in mm along the \n"
		"detector axes from pixel (0, 0) to the point at which the beam \n"
		"intersects the detector at the indices given *indexfast and \n"
		"*indexslow. cbf_set_reference_beam_center sets the displacments in \n"
		"the array_structure_list_axis category to place the beam center at \n"
		"the position given in mm by *centerfast and *centerslow as the \n"
		"displacements in mm along the detector axes from pixel (0, 0) to the \n"
		"point at which the beam intersects the detector at the indices given \n"
		"by *indexfast and *indexslow. In order to achieve consistent results, \n"
		"a reference detector should be used for detector to have all axes at \n"
		"their reference settings.\n"
		"Note that the precedence 1 axis is the fastest axis, so that \n"
		"*centerfast and *indexfast are the fast axis components of the center \n"
		"and *centerslow and *indexslow are the slow axis components of the \n"
		"center.\n"
		"The _fs calls give the displacments in a fast-to-slow order. The \n"
		"calls with no suffix and the calls _sf calls give the displacements \n"
		"in slow-to-fast order\n"
		"Any of the destination pointers may be NULL for getting the beam \n"
		"center. For setting the beam axis, either the indices of the center \n"
		"must not be NULL.\n"
		"The indices are non-negative for beam centers within the detector \n"
		"surface, but the center for an axis with a negative increment will be \n"
		"negative for a beam center within the detector surface.\n"
		"For cbf_set_beam_center if the diffrn_data_frame category exists with \n"
		"a row for the corresponding element id, the values will be set for \n"
		"_diffrn_data_frame.center_fast and _diffrn_data_frame.center_slow in \n"
		"millimetres and the value of _diffrn_data_frame.center_units will be \n"
		"set to 'mm'.\n"
		"For cbf_set_reference_beam_center if the diffrn_detector_element \n"
		"category exists with a row for the corresponding element id, the \n"
		"values will be set for _diffrn_detector_element.reference_center_fast \n"
		"and _diffrn_detector_element.reference_center_slow in millimetres and \n"
		"the value of _diffrn_detector_element.reference_units will be set to \n"
		"'mm'.\n"
		"ARGUMENTS\n"
		"detector     Detector handle. indexfast    Pointer to the destination \n"
		"fast index. indexslow    Pointer to the destination slow index. \n"
		"centerfast   Pointer to the destination displacement along the fast \n"
		"axis. centerslow   Pointer to the destination displacement along the \n"
		"slow axis.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_get_pixel_normal", _wrap_cbf_detector_struct_get_pixel_normal, METH_VARARGS, (char *)"\n"
		"Returns : double normal1,double normal2,double normal3\n"
		"*args   : double index1,double index2\n"
		"\n"
		"C prototype: int cbf_get_pixel_normal (cbf_detector detector,\n"
		"                 double indexslow,      double indexfast, double *normal1,\n"
		"                 double *normal2, double *normal3);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_detector_normal, cbf_get_pixel_normal_fs and \n"
		"cbf_get_pixel_normal_sf set *normal1, *normal2, and *normal3 to the 3 \n"
		"components of the of the normal vector to the pixel at (indexfast, \n"
		"indexslow). The vector is normalized.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"detector    Detector handle. indexslow   Slow index. indexfast   Fast \n"
		"index. normal1     Pointer to the destination x component of the \n"
		"normal vector. normal2     Pointer to the destination y component of \n"
		"the normal vector. normal3     Pointer to the destination z component \n"
		"of the normal vector.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_detector_struct_swigregister", cbf_detector_struct_swigregister, METH_VARARGS, NULL},
	 { (char *)"cbf_handle_struct_node_set", _wrap_cbf_handle_struct_node_set, METH_VARARGS, (char *)"cbf_handle_struct_node_set(cbf_handle_struct self, cbf_node node)"},
	 { (char *)"cbf_handle_struct_node_get", _wrap_cbf_handle_struct_node_get, METH_VARARGS, (char *)"cbf_handle_struct_node_get(cbf_handle_struct self) -> cbf_node"},
	 { (char *)"cbf_handle_struct_row_set", _wrap_cbf_handle_struct_row_set, METH_VARARGS, (char *)"cbf_handle_struct_row_set(cbf_handle_struct self, int row)"},
	 { (char *)"cbf_handle_struct_row_get", _wrap_cbf_handle_struct_row_get, METH_VARARGS, (char *)"cbf_handle_struct_row_get(cbf_handle_struct self) -> int"},
	 { (char *)"cbf_handle_struct_search_row_set", _wrap_cbf_handle_struct_search_row_set, METH_VARARGS, (char *)"cbf_handle_struct_search_row_set(cbf_handle_struct self, int search_row)"},
	 { (char *)"cbf_handle_struct_search_row_get", _wrap_cbf_handle_struct_search_row_get, METH_VARARGS, (char *)"cbf_handle_struct_search_row_get(cbf_handle_struct self) -> int"},
	 { (char *)"new_cbf_handle_struct", _wrap_new_cbf_handle_struct, METH_VARARGS, (char *)"new_cbf_handle_struct() -> cbf_handle_struct"},
	 { (char *)"delete_cbf_handle_struct", _wrap_delete_cbf_handle_struct, METH_VARARGS, (char *)"delete_cbf_handle_struct(cbf_handle_struct self)"},
	 { (char *)"cbf_handle_struct_select_datablock", _wrap_cbf_handle_struct_select_datablock, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_datablock (cbf_handle handle,\n"
		"                 unsigned int datablock);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_datablock selects data block number datablock as the \n"
		"current data block.\n"
		"The first data block is number 0.\n"
		"If the data block does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. datablock   Number of the data block to \n"
		"select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_force_new_datablock", _wrap_cbf_handle_struct_force_new_datablock, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_force_new_datablock (cbf_handle handle,\n"
		"                 const char    *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_force_new_datablock creates a new data block with name \n"
		"datablockname and makes it the current data block. Duplicate data \n"
		"block names are allowed. cbf_force_new_saveframe creates a new savew \n"
		"frame with name saveframename and makes it the current save frame. \n"
		"Duplicate save frame names are allowed.\n"
		"Even if a save frame with this name already exists, a new save frame \n"
		"is created and becomes the current save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_3d_image_fs_as_string", _wrap_cbf_handle_struct_get_3d_image_fs_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimfast,int ndimmid,\n"
		"          int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_3d_image_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, int elsign,      size_t ndimfast,\n"
		"                 size_t ndimmid, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_reset_datablocks", _wrap_cbf_handle_struct_reset_datablocks, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_datablocks (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_datablocks deletes all categories from all data blocks.\n"
		"The current data block does not change.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_tag_category", _wrap_cbf_handle_struct_set_tag_category, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String tagname,String categoryname_in\n"
		"\n"
		"C prototype: int cbf_set_tag_category (cbf_handle handle, const char* tagname,\n"
		"                 const      char* categoryname_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_category sets categoryname to the category associated \n"
		"with tagname in the dictionary associated with handle. \n"
		"cbf_set_tag_category upddates the dictionary associated with handle \n"
		"to indicated that tagname is in category categoryname_in.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. tagname           tag name. \n"
		"categoryname      pointer to a returned category name. \n"
		"categoryname_in   input category name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_tag_root", _wrap_cbf_handle_struct_require_tag_root, METH_VARARGS, (char *)"\n"
		"Returns : String tagroot\n"
		"*args   : String tagname\n"
		"\n"
		"C prototype: int cbf_require_tag_root (cbf_handle handle, const char* tagname,\n"
		"                 const      char** tagroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_root sets *tagroot to the root tag of which tagname is \n"
		"an alias. cbf_set_tag_root sets tagname as an alias of tagroot_in in \n"
		"the dictionary associated with handle, creating the dictionary if \n"
		"necessary. cbf_require_tag_root sets *tagroot to the root tag of \n"
		"which tagname is an alias, if there is one, or to the value of \n"
		"tagname, if tagname is not an alias.\n"
		"A returned tagroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. tagname      tag name which may be an alias. \n"
		"tagroot      pointer to a returned tag root name. tagroot_in   input \n"
		"tag root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_row_number", _wrap_cbf_handle_struct_row_number, METH_VARARGS, (char *)"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_row_number (cbf_handle handle, unsigned int *row);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_row_number sets *row to the number of the current row of the \n"
		"current category.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. row      Pointer to the destination row number.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_image", _wrap_cbf_handle_struct_set_image, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_bin_sizes", _wrap_cbf_handle_struct_set_bin_sizes, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer element_number,Float slowbinsize_in,Float fastbinsize_in\n"
		"\n"
		"C prototype: int cbf_set_bin_sizes(cbf_handle handle,\n"
		"                 unsigned int element_number,      double slowbinsize_in,\n"
		"                double fastbinsize_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_bin_sizes sets slowbinsize to point to the value of the \n"
		"number of pixels composing one array element in the dimension that \n"
		"changes at the second-fastest rate and fastbinsize to point to the \n"
		"value of the number of pixels composing one array element in the \n"
		"dimension that changes at the fastest rate for the dectector element \n"
		"with the ordinal element_number. cbf_set_bin_sizes sets the the pixel \n"
		"bin sizes in the  \"array_intensities \" category to the values of \n"
		"slowbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the second-fastest rate and \n"
		"fastbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate for the dectector \n"
		"element with the ordinal element_number.\n"
		"In order to allow for software binning involving fractions of pixels, \n"
		"the bin sizes are doubles rather than ints.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. slowbinsize      Pointer to the \n"
		"returned number of pixels composing one array element in the \n"
		"dimension that changes at the second-fastest rate. fastbinsize      \n"
		"Pointer to the returned number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate. slowbinsize_in   \n"
		"The number of pixels composing one array element in the dimension \n"
		"that changes at the second-fastest rate. fastbinsize_in   The number \n"
		"of pixels composing one array element in the dimension that changes \n"
		"at the fastest rate.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_new_row", _wrap_cbf_handle_struct_new_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_row adds a new row to the current category and makes it the \n"
		"current row.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_rewind_saveframe", _wrap_cbf_handle_struct_rewind_saveframe, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_saveframe (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_category makes the first category in the current data \n"
		"block the current category. cbf_rewind_saveframe makes the first \n"
		"saveframe in the current data block the current saveframe. \n"
		"cbf_rewind_blockitem makes the first blockitem (category or \n"
		"saveframe) in the current data block the current blockitem. The type \n"
		"of the blockitem (CBF_CATEGORY or CBF_SAVEFRAME) is returned in type.\n"
		"If there are no categories, saveframes or blockitems the function \n"
		"returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. type     CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_realarrayparameters", _wrap_cbf_handle_struct_get_realarrayparameters, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elements\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_pixel_size_sf", _wrap_cbf_handle_struct_get_pixel_size_sf, METH_VARARGS, (char *)"\n"
		"Returns : Float pixel_size\n"
		"*args   : Int element_number,Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_pixel_size_sf(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_size and cbf_get_pixel_size_sf set *psize to point to \n"
		"the double value in millimeters of the axis axis_number of the \n"
		"detector element element_number. The axis_number is numbered from 1, \n"
		"starting with the slowest axis. cbf_get_pixel_size_fs sets *psize to \n"
		"point to the double value in millimeters of the axis axis_number of \n"
		"the detector element element_number. The axis_number is numbered from \n"
		"1, starting with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"\" category, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, starting from 1 for the fastest for cbf_get_pixel_size and \n"
		"cbf_get_pixel_size_fs and the slowest for cbf_get_pixel_size_sf. \n"
		"psize            Pointer to the destination pixel size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_force_new_category", _wrap_cbf_handle_struct_force_new_category, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_force_new_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_force_new_category creates a new category in the current data \n"
		"block with name categoryname and makes it the current category. \n"
		"Duplicate category names are allowed.\n"
		"Even if a category with this name already exists, a new category of \n"
		"the same name is created and becomes the current category. The allows \n"
		"for the creation of unlooped tag/value lists drawn from the same \n"
		"category.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the new \n"
		"category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_force_new_saveframe", _wrap_cbf_handle_struct_force_new_saveframe, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_force_new_saveframe (cbf_handle handle,\n"
		"                 const char    *saveframename);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_force_new_datablock creates a new data block with name \n"
		"datablockname and makes it the current data block. Duplicate data \n"
		"block names are allowed. cbf_force_new_saveframe creates a new savew \n"
		"frame with name saveframename and makes it the current save frame. \n"
		"Duplicate save frame names are allowed.\n"
		"Even if a save frame with this name already exists, a new save frame \n"
		"is created and becomes the current save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_count_datablocks", _wrap_cbf_handle_struct_count_datablocks, METH_VARARGS, (char *)"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_datablocks (cbf_handle handle,\n"
		"                 unsigned int *datablocks);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_datablocks puts the number of data blocks in *datablocks .\n"
		"ARGUMENTS\n"
		"handle       CBF handle. datablocks   Pointer to the destination data \n"
		"block count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_row", _wrap_cbf_handle_struct_find_row, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_row (cbf_handle handle, const char *value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_row makes the first row in the current column with value \n"
		"value the current row.\n"
		"The comparison is case-sensitive.\n"
		"If a matching row does not exist, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. value    The value of the row to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_select_column", _wrap_cbf_handle_struct_select_column, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_column (cbf_handle handle, unsigned int column);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_column selects column number column in the current \n"
		"category as the current column.\n"
		"The first column is number 0.\n"
		"The current row is not affected\n"
		"If the column does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. column   Number of the column to select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_construct_detector", _wrap_cbf_handle_struct_construct_detector, METH_VARARGS, (char *)"\n"
		"Returns : pycbf detector object\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_construct_detector (cbf_handle handle,\n"
		"                 cbf_detector *detector,      unsigned int element_number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_detector constructs a detector object for detector \n"
		"element number element_number using the description in the CBF object \n"
		"handle and initialises the detector handle *detector.\n"
		"cbf_construct_reference_detector constructs a detector object for \n"
		"detector element number element_number using the description in the \n"
		"CBF object handle and initialises the detector handle *detector using \n"
		"the reference settings of the axes. cbf_require_reference_detector is \n"
		"similar, but try to force the creations of missing intermediate \n"
		"categories needed to construct a detector object.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. detector         Pointer to the \n"
		"destination detector handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_rewind_column", _wrap_cbf_handle_struct_rewind_column, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_column (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_column makes the first column in the current category the \n"
		"current column.\n"
		"If there are no columns, the function returns CBF_NOTFOUND.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_column_doublevalue", _wrap_cbf_handle_struct_require_column_doublevalue, METH_VARARGS, (char *)"\n"
		"Returns : Float defaultvalue\n"
		"*args   : String columnname,Float Value\n"
		"\n"
		"C prototype: int cbf_require_column_doublevalue (cbf_handle handle,\n"
		"                 const char      *columnname, double *number,\n"
		"                 const double defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column_doublevalue sets *number to the value of the ASCII \n"
		"item at the current row for the column given with the name given by \n"
		"*columnname, with the value interpreted as a decimal floating-point \n"
		"number, or to the number given by defaultvalue if the item cannot be \n"
		"found.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. columnname     Name of the column \n"
		"containing the number. number         pointer to the location to \n"
		"receive the floating-point value. defaultvalue   Value to use if the \n"
		"requested column and value cannot be found.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_datestamp", _wrap_cbf_handle_struct_get_datestamp, METH_VARARGS, (char *)"\n"
		"Returns : int year,int month,int day,int hour,int minute,double second,\n"
		"          int timezone\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_datestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 int      *year, int *month, int *day, int *hour, int *minute,\n"
		"                 double *second, int      *timezone);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_datestamp sets *year, *month, *day, *hour, *minute and \n"
		"*second to the corresponding values of the collection timestamp. \n"
		"*timezone is set to timezone difference from UTC in minutes. The \n"
		"parameter < i>reserved is presently unused and should be set to 0.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused. Any value other than 0 is \n"
		"invalid. year       Pointer to the destination timestamp year. month  \n"
		"    Pointer to the destination timestamp month (1-12). day        \n"
		"Pointer to the destination timestamp day (1-31). hour       Pointer \n"
		"to the destination timestamp hour (0-23). minute     Pointer to the \n"
		"destination timestamp minute (0-59). second     Pointer to the \n"
		"destination timestamp second (0-60.0). timezone   Pointer to the \n"
		"destination timezone difference from UTC in minutes.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integervalue", _wrap_cbf_handle_struct_get_integervalue, METH_VARARGS, (char *)"\n"
		"Returns : int\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integervalue (cbf_handle handle, int *number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integervalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal integer. \n"
		"cbf_require_integervalue sets *number to the value of the ASCII item \n"
		"at the current column and row interpreted as a decimal integer, \n"
		"setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         pointer to the number. \n"
		"defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_crystal_id", _wrap_cbf_handle_struct_get_crystal_id, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_crystal_id (cbf_handle handle,\n"
		"                 const char **crystal_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_crystal_id sets *crystal_id to point to the ASCII value of \n"
		"the  \"diffrn.crystal_id \" entry.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"The value will be valid as long as the item exists and has not been \n"
		"set to a new value.\n"
		"The value must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. crystal_id   Pointer to the destination \n"
		"value pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_doublevalue", _wrap_cbf_handle_struct_get_doublevalue, METH_VARARGS, (char *)"\n"
		"Returns : double\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_doublevalue (cbf_handle handle, double *number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_doublevalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal floating-point \n"
		"number. cbf_require_doublevalue sets *number to the value of the \n"
		"ASCII item at the current column and row interpreted as a decimal \n"
		"floating-point number, setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         Pointer to the destination \n"
		"number. defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_unit_cell", _wrap_cbf_handle_struct_get_unit_cell, METH_VARARGS, (char *)"\n"
		"Returns : Float a,Float b,Float c,Float alpha,Float beta,Float gamma\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_unit_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_unit_cell sets cell[0:2] to the double values of the cell \n"
		"edge lengths a, b and c in AAngstroms, cell[3:5] to the double values \n"
		"of the cell angles a, b and g in degrees, cell_esd[0:2] to the double \n"
		"values of the estimated strandard deviations of the cell edge lengths \n"
		"a, b and c in AAngstroms, cell_esd[3:5] to the double values of the \n"
		"estimated standard deviations of the the cell angles a, b and g in \n"
		"degrees.\n"
		"The values returned are retrieved from the first row of the  \"cell \n"
		"\" category. The value of  \"_cell.entry_id \" is ignored.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the cell parameters are not retrieved.\n"
		"If cell_esd is NULL, the cell parameter esds are not retrieved.\n"
		"If the  \"cell \" category is present, but some of the values are \n"
		"missing, zeros are returned for the missing values.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the destination array of \n"
		"6 doubles for the cell parameters. cell_esd   Pointer to the \n"
		"destination array of 6 doubles for the cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. No errors is \n"
		"returned for missing values if the  \"cell \" category exists.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_unit_cell_esd", _wrap_cbf_handle_struct_get_unit_cell_esd, METH_VARARGS, (char *)"cbf_handle_struct_get_unit_cell_esd(cbf_handle_struct self)"},
	 { (char *)"cbf_handle_struct_remove_column", _wrap_cbf_handle_struct_remove_column, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_column (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_column deletes the current column.\n"
		"The current column becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_rewind_blockitem", _wrap_cbf_handle_struct_rewind_blockitem, METH_VARARGS, (char *)"\n"
		"Returns : CBF_NODETYPE\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_blockitem (cbf_handle handle,\n"
		"                 CBF_NODETYPE * type);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_category makes the first category in the current data \n"
		"block the current category. cbf_rewind_saveframe makes the first \n"
		"saveframe in the current data block the current saveframe. \n"
		"cbf_rewind_blockitem makes the first blockitem (category or \n"
		"saveframe) in the current data block the current blockitem. The type \n"
		"of the blockitem (CBF_CATEGORY or CBF_SAVEFRAME) is returned in type.\n"
		"If there are no categories, saveframes or blockitems the function \n"
		"returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. type     CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_value", _wrap_cbf_handle_struct_get_value, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_value (cbf_handle handle, const char **value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_value sets *value to point to the ASCII value of the item at \n"
		"the current column and row. cbf_require_value sets *value to point to \n"
		"the ASCII value of the item at the current column and row, creating \n"
		"the data item if necessary and initializing it to a copy of \n"
		"defaultvalue.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"The value will be valid as long as the item exists and has not been \n"
		"set to a new value.\n"
		"The value must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. value          Pointer to the destination \n"
		"value pointer. defaultvalue   Default value character string.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_count_categories", _wrap_cbf_handle_struct_count_categories, METH_VARARGS, (char *)"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_categories (cbf_handle handle,\n"
		"                 unsigned int *categories);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_categories puts the number of categories in the current \n"
		"data block in *categories.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. categories   Pointer to the destination \n"
		"category count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_read_widefile", _wrap_cbf_handle_struct_read_widefile, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String filename,Integer headers\n"
		"\n"
		"C prototype: int cbf_read_widefile (cbf_handle handle, FILE *file, int flags);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_read_file reads the CBF or CIF file file into the CBF object \n"
		"specified by handle, using the CIF 1.0 convention of 80 character \n"
		"lines. cbf_read_widefile reads the CBF or CIF file file into the CBF \n"
		"object specified by handle, using the CIF 1.1 convention of 2048 \n"
		"character lines. A warning is issued to stderr for ascii lines over \n"
		"the limit. No test is performed on binary sections.\n"
		"Validation is performed in three ways levels: during the lexical \n"
		"scan, during the parse, and, if a dictionary was converted, against \n"
		"the value types, value enumerations, categories and parent-child \n"
		"relationships specified in the dictionary.\n"
		"flags controls the interpretation of binary section headers, the \n"
		"parsing of brackets constructs and the parsing of treble-quoted \n"
		"strings.\n"
		"MSG_DIGEST:               Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digest value. If the digests \n"
		"do not match, the call will return CBF_FORMAT. This evaluation and \n"
		"comparison is delayed (a  \"lazy \" evaluation) to ensure maximal \n"
		"processing efficiency. If an immediately evaluation is required, see \n"
		"MSG_DIGESTNOW, below. MSG_DIGESTNOW:            Instructs CBFlib to \n"
		"check that the digest of the binary section matches any header \n"
		"digeste value. If the digests do not match, the call will return \n"
		"CBF_FORMAT. This evaluation and comparison is performed during \n"
		"initial parsing of the section to ensure timely error reporting at \n"
		"the expense of processing efficiency. If a more efficient delayed ( \n"
		"\"lazy \") evaluation is required, see MSG_DIGEST, above. \n"
		"MSG_DIGESTWARN:           Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digeste value. If the \n"
		"digests do not match, a warning message will be sent to stderr, but \n"
		"processing will attempt to continue. This evaluation and comparison \n"
		"is first performed during initial parsing of the section to ensure \n"
		"timely error reporting at the expense of processing efficiency. An \n"
		"mismatch of the message digest usually indicates a serious error, but \n"
		"it is sometimes worth continuing processing to try to isolate the \n"
		"cause of the error. Use this option with caution. MSG_NODIGEST:       \n"
		"      Do not check the digest (default). PARSE_BRACKETS:           \n"
		"Accept DDLm bracket-delimited [item,item,...item] or \n"
		"{item,item,...item} or (item,item,...item) constructs as valid, \n"
		"stripping non-quoted embedded whitespace and comments. These \n"
		"constructs may span multiple lines. PARSE_LIBERAL_BRACKETS:   Accept \n"
		"DDLm bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping embedded \n"
		"non-quoted, non-separating whitespace and comments. These constructs \n"
		"may span multiple lines. In this case, whitespace may be used as an \n"
		"alternative to the comma. PARSE_TRIPLE_QUOTES:      Accept DDLm \n"
		"triple-quoted  \" \" \"item,item,...item \" \" \" or \n"
		"'''item,item,...item''' constructs as valid, stripping embedded \n"
		"whitespace and comments. These constructs may span multiple lines. If \n"
		"this flag is set, then ''' will not be interpreted as a quoted \n"
		"apoptrophe and  \" \" \" will not be interpreted as a quoted double \n"
		"quote mark and PARSE_NOBRACKETS:         Do not accept DDLm \n"
		"bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping non-quoted \n"
		"embedded whitespace and comments. These constructs may span multiple \n"
		"lines. PARSE_NOTRIPLE_QUOTES:    No not accept DDLm triple-quoted  \" \n"
		"\" \"item,item,...item \" \" \" or '''item,item,...item''' constructs \n"
		"as valid, stripping embedded whitespace and comments. These \n"
		"constructs may span multiple lines. If this flag is set, then ''' \n"
		"will be interpreted as a quoted apostrophe and  \" \" \" will be \n"
		"interpreted as a quoted double quote mark.\n"
		"CBFlib defers reading binary sections as long as possible. In the \n"
		"current version of CBFlib, this means that:\n"
		"1. The file must be a random-access file opened in binary mode (fopen \n"
		"( ,\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_wavelength", _wrap_cbf_handle_struct_set_wavelength, METH_VARARGS, (char *)"\n"
		"Returns : double wavelength\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_wavelength (cbf_handle handle, double wavelength);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_wavelength sets the current wavelength in AA to wavelength.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. wavelength   Wavelength in AA.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_pixel_size_sf", _wrap_cbf_handle_struct_set_pixel_size_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Int element_number,Int axis_number,Float pixel size\n"
		"\n"
		"C prototype: int cbf_set_pixel_size_sf(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_pixel_size and cbf_set_pixel_size_sf set the item in the \n"
		"&quote;size&quote; column of the  \"array_structure_list \" category \n"
		"at the row which matches axis axis_number of the detector element \n"
		"element_number converting the double pixel size psize from meters to \n"
		"millimeters in storing it in the  \"size \" column for the axis \n"
		"axis_number of the detector element element_number. The axis_number \n"
		"is numbered from 1, starting with the slowest axis. \n"
		"cbf_set_pixel_size_fs sets the item\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_diffrn_id", _wrap_cbf_handle_struct_get_diffrn_id, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_diffrn_id (cbf_handle handle,\n"
		"                 const char **diffrn_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_diffrn_id sets *diffrn_id to point to the ASCII value of the  \n"
		"\"diffrn.id \" entry. cbf_require_diffrn_id also sets *diffrn_id to \n"
		"point to the ASCII value of the  \"diffrn.id \" entry, but, if the  \n"
		"\"diffrn.id \" entry does not exist, it sets the value in the CBF and \n"
		"in*diffrn_id to the character string given by default_id, creating \n"
		"the category and column is necessary.\n"
		"The diffrn_id will be valid as long as the item exists and has not \n"
		"been set to a new value.\n"
		"The diffrn_id must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. diffrn_id    Pointer to the destination \n"
		"value pointer. default_id   Character string default value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_datablock", _wrap_cbf_handle_struct_find_datablock, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_datablock (cbf_handle handle,\n"
		"                 const char *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_datablock makes the data block with name datablockname the \n"
		"current data block.\n"
		"The comparison is case-insensitive.\n"
		"If the data block does not exist, the function returns CBF_NOTFOUND.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the data \n"
		"block to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_polarization", _wrap_cbf_handle_struct_get_polarization, METH_VARARGS, (char *)"\n"
		"Returns : float polarizn_source_ratio,float polarizn_source_norm\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_polarization (cbf_handle handle,\n"
		"                 double      *polarizn_source_ratio,\n"
		"                 double *polarizn_source_norm);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_polarization sets *polarizn_source_ratio and \n"
		"*polarizn_source_norm to the corresponding source polarization \n"
		"parameters.\n"
		"Either destination pointer may be NULL.\n"
		"ARGUMENTS\n"
		"handle                  CBF handle. polarizn_source_ratio   Pointer \n"
		"to the destination polarizn_source_ratio. polarizn_source_norm    \n"
		"Pointer to the destination polarizn_source_norm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_select_category", _wrap_cbf_handle_struct_select_category, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_category (cbf_handle handle,\n"
		"                 unsigned int category);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_category selects category number category in the current \n"
		"data block as the current category.\n"
		"The first category is number 0.\n"
		"The current column and row become undefined.\n"
		"If the category does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. category   Number of the category to select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_pixel_size_fs", _wrap_cbf_handle_struct_get_pixel_size_fs, METH_VARARGS, (char *)"\n"
		"Returns : Float pixel_size\n"
		"*args   : Int element_number,Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_pixel_size_fs(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_size and cbf_get_pixel_size_sf set *psize to point to \n"
		"the double value in millimeters of the axis axis_number of the \n"
		"detector element element_number. The axis_number is numbered from 1, \n"
		"starting with the slowest axis. cbf_get_pixel_size_fs sets *psize to \n"
		"point to the double value in millimeters of the axis axis_number of \n"
		"the detector element element_number. The axis_number is numbered from \n"
		"1, starting with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"\" category, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, starting from 1 for the fastest for cbf_get_pixel_size and \n"
		"cbf_get_pixel_size_fs and the slowest for cbf_get_pixel_size_sf. \n"
		"psize            Pointer to the destination pixel size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_read_file", _wrap_cbf_handle_struct_read_file, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String filename,Integer headers\n"
		"\n"
		"C prototype: int cbf_read_file (cbf_handle handle, FILE *file, int flags);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_read_file reads the CBF or CIF file file into the CBF object \n"
		"specified by handle, using the CIF 1.0 convention of 80 character \n"
		"lines. cbf_read_widefile reads the CBF or CIF file file into the CBF \n"
		"object specified by handle, using the CIF 1.1 convention of 2048 \n"
		"character lines. A warning is issued to stderr for ascii lines over \n"
		"the limit. No test is performed on binary sections.\n"
		"Validation is performed in three ways levels: during the lexical \n"
		"scan, during the parse, and, if a dictionary was converted, against \n"
		"the value types, value enumerations, categories and parent-child \n"
		"relationships specified in the dictionary.\n"
		"flags controls the interpretation of binary section headers, the \n"
		"parsing of brackets constructs and the parsing of treble-quoted \n"
		"strings.\n"
		"MSG_DIGEST:               Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digest value. If the digests \n"
		"do not match, the call will return CBF_FORMAT. This evaluation and \n"
		"comparison is delayed (a  \"lazy \" evaluation) to ensure maximal \n"
		"processing efficiency. If an immediately evaluation is required, see \n"
		"MSG_DIGESTNOW, below. MSG_DIGESTNOW:            Instructs CBFlib to \n"
		"check that the digest of the binary section matches any header \n"
		"digeste value. If the digests do not match, the call will return \n"
		"CBF_FORMAT. This evaluation and comparison is performed during \n"
		"initial parsing of the section to ensure timely error reporting at \n"
		"the expense of processing efficiency. If a more efficient delayed ( \n"
		"\"lazy \") evaluation is required, see MSG_DIGEST, above. \n"
		"MSG_DIGESTWARN:           Instructs CBFlib to check that the digest \n"
		"of the binary section matches any header digeste value. If the \n"
		"digests do not match, a warning message will be sent to stderr, but \n"
		"processing will attempt to continue. This evaluation and comparison \n"
		"is first performed during initial parsing of the section to ensure \n"
		"timely error reporting at the expense of processing efficiency. An \n"
		"mismatch of the message digest usually indicates a serious error, but \n"
		"it is sometimes worth continuing processing to try to isolate the \n"
		"cause of the error. Use this option with caution. MSG_NODIGEST:       \n"
		"      Do not check the digest (default). PARSE_BRACKETS:           \n"
		"Accept DDLm bracket-delimited [item,item,...item] or \n"
		"{item,item,...item} or (item,item,...item) constructs as valid, \n"
		"stripping non-quoted embedded whitespace and comments. These \n"
		"constructs may span multiple lines. PARSE_LIBERAL_BRACKETS:   Accept \n"
		"DDLm bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping embedded \n"
		"non-quoted, non-separating whitespace and comments. These constructs \n"
		"may span multiple lines. In this case, whitespace may be used as an \n"
		"alternative to the comma. PARSE_TRIPLE_QUOTES:      Accept DDLm \n"
		"triple-quoted  \" \" \"item,item,...item \" \" \" or \n"
		"'''item,item,...item''' constructs as valid, stripping embedded \n"
		"whitespace and comments. These constructs may span multiple lines. If \n"
		"this flag is set, then ''' will not be interpreted as a quoted \n"
		"apoptrophe and  \" \" \" will not be interpreted as a quoted double \n"
		"quote mark and PARSE_NOBRACKETS:         Do not accept DDLm \n"
		"bracket-delimited [item,item,...item] or {item,item,...item} or \n"
		"(item,item,...item) constructs as valid, stripping non-quoted \n"
		"embedded whitespace and comments. These constructs may span multiple \n"
		"lines. PARSE_NOTRIPLE_QUOTES:    No not accept DDLm triple-quoted  \" \n"
		"\" \"item,item,...item \" \" \" or '''item,item,...item''' constructs \n"
		"as valid, stripping embedded whitespace and comments. These \n"
		"constructs may span multiple lines. If this flag is set, then ''' \n"
		"will be interpreted as a quoted apostrophe and  \" \" \" will be \n"
		"interpreted as a quoted double quote mark.\n"
		"CBFlib defers reading binary sections as long as possible. In the \n"
		"current version of CBFlib, this means that:\n"
		"1. The file must be a random-access file opened in binary mode (fopen \n"
		"( ,\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_datablock_name", _wrap_cbf_handle_struct_datablock_name, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_datablock_name (cbf_handle handle,\n"
		"                 const char **datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_datablock_name sets *datablockname to point to the name of the \n"
		"current data block.\n"
		"The data block name will be valid as long as the data block exists \n"
		"and has not been renamed.\n"
		"The name must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   Pointer to the \n"
		"destination data block name pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_realarray_wdims", _wrap_cbf_handle_struct_set_realarray_wdims, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimfast,int dimmid,int dimslow,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_realarray_wdims (cbf_handle handle,\n"
		"                 unsigned int compression,    int binary_id, void *array,\n"
		"                 size_t elsize, size_t elements, const char    *byteorder,\n"
		"                 size_t dimfast, size_t dimmid, size_t dimslow,\n"
		"                 size_t    padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_construct_reference_detector", _wrap_cbf_handle_struct_construct_reference_detector, METH_VARARGS, (char *)"\n"
		"Returns : pycbf detector object\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_construct_reference_detector (cbf_handle handle,\n"
		"                 cbf_detector      *detector, unsigned int element_number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_detector constructs a detector object for detector \n"
		"element number element_number using the description in the CBF object \n"
		"handle and initialises the detector handle *detector.\n"
		"cbf_construct_reference_detector constructs a detector object for \n"
		"detector element number element_number using the description in the \n"
		"CBF object handle and initialises the detector handle *detector using \n"
		"the reference settings of the axes. cbf_require_reference_detector is \n"
		"similar, but try to force the creations of missing intermediate \n"
		"categories needed to construct a detector object.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. detector         Pointer to the \n"
		"destination detector handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_real_3d_image_fs_as_string", _wrap_cbf_handle_struct_get_real_3d_image_fs_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimfast,int ndimmid,int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_real_3d_image_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimfast,\n"
		"                 size_t ndimmid, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_rewind_row", _wrap_cbf_handle_struct_rewind_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_row makes the first row in the current category the \n"
		"current row.\n"
		"If there are no rows, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_axis_setting", _wrap_cbf_handle_struct_get_axis_setting, METH_VARARGS, (char *)"\n"
		"Returns : Float start,Float increment\n"
		"*args   : String axis_id\n"
		"\n"
		"C prototype: int cbf_get_axis_setting (cbf_handle handle,\n"
		"                 unsigned int reserved,      const char *axis_id, double *start,\n"
		"                 double *increment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_axis_setting sets *start and *increment to the corresponding \n"
		"values of the axis axis_id.\n"
		"Either of the destination pointers may be NULL.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. reserved    Unused. Any value other than 0 is \n"
		"invalid. axis_id     Axis id. start       Pointer to the destination \n"
		"start value. increment   Pointer to the destination increment value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_column", _wrap_cbf_handle_struct_require_column, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_require_column (cbf_handle handle,\n"
		"                 const char *columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column makes the columns in the current category with \n"
		"name columnname the current column, if it exists, or creates it if it \n"
		"does not.\n"
		"The comparison is case-insensitive.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   The name of column to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_timestamp", _wrap_cbf_handle_struct_get_timestamp, METH_VARARGS, (char *)"\n"
		"Returns : Float time,Integer timezone\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_timestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 double      *time, int *timezone);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_timestamp sets *time to the collection timestamp in seconds \n"
		"since January 1 1970. *timezone is set to timezone difference from \n"
		"UTC in minutes. The parameter reserved is presently unused and should \n"
		"be set to 0.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused. Any value other than 0 is \n"
		"invalid. time       Pointer to the destination collection timestamp. \n"
		"timezone   Pointer to the destination timezone difference.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_nextrow", _wrap_cbf_handle_struct_find_nextrow, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_nextrow (cbf_handle handle, const char *value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_nextrow makes the makes the next row in the current column \n"
		"with value value the current row. The search starts from the row \n"
		"following the last row found with cbf_find_row or cbf_find_nextrow, \n"
		"or from the current row if the current row was defined using any \n"
		"other function.\n"
		"The comparison is case-sensitive.\n"
		"If no more matching rows exist, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. value    the value to search for.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_realarrayparameters_wdims_sf", _wrap_cbf_handle_struct_get_realarrayparameters_wdims_sf, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elements,char **bo,\n"
		"          int *bolen,int dimslow,int dimmid,int dimfast,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters_wdims_sf (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements, const char    **byteorder, size_t *dimslow,\n"
		"                 size_t *dimmid, size_t *dimfast, size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_reset_datablock", _wrap_cbf_handle_struct_reset_datablock, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_datablock deletes all categories from the current data \n"
		"block. cbf_reset_saveframe deletes all categories from the current \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_3d_image_fs", _wrap_cbf_handle_struct_set_3d_image_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimfast,int dimmid,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_3d_image_fs(cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, unsigned int compression,\n"
		"                 void *array,      size_t elsize, int elsign, size_t ndimfast,\n"
		"                 size_t ndimmid, size_t      ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_saveframename", _wrap_cbf_handle_struct_set_saveframename, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_saveframename (cbf_handle handle,\n"
		"                 const char *saveframename);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_datablockname changes the name of the current data block to \n"
		"datablockname. cbf_set_saveframename changes the name of the current \n"
		"save frame to saveframename.\n"
		"If a data block or save frame with this name already exists \n"
		"(comparison is case-insensitive), the function returns CBF_IDENTICAL.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The new data block name. \n"
		"datablockname   The new save frame name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_integervalue", _wrap_cbf_handle_struct_require_integervalue, METH_VARARGS, (char *)"\n"
		"Returns : Int number\n"
		"*args   : Int thedefault\n"
		"\n"
		"C prototype: int cbf_require_integervalue (cbf_handle handle, int *number,\n"
		"                 int    defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integervalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal integer. \n"
		"cbf_require_integervalue sets *number to the value of the ASCII item \n"
		"at the current column and row interpreted as a decimal integer, \n"
		"setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         pointer to the number. \n"
		"defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integerarrayparameters", _wrap_cbf_handle_struct_get_integerarrayparameters, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_real_3d_image_sf", _wrap_cbf_handle_struct_set_real_3d_image_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_3d_image_sf(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimslow, size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_write_file", _wrap_cbf_handle_struct_write_file, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String filename,Integer ciforcbf,Integer Headers,Integer encoding\n"
		"\n"
		"C prototype: int cbf_write_file (cbf_handle handle, FILE *file, int readable,\n"
		"                 int    ciforcbf, int flags, int encoding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_write_file writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.0 conventions of 80 character lines. \n"
		"cbf_write_widefile writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.1 conventions of 2048 character lines. A \n"
		"warning is issued to stderr for ascii lines over the limit, and an \n"
		"attempt is made to fold lines to fit. No test is performed on binary \n"
		"sections.\n"
		"If a dictionary has been provided, aliases will be applied on output.\n"
		"Unlike cbf_read_file, the file does not have to be random-access.\n"
		"If the file is random-access and readable, readable can be set to \n"
		"non-0 to indicate to CBFlib that the file can be used as a buffer to \n"
		"conserve disk space. If the file is not random-access or not \n"
		"readable, readable must be 0.\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_divergence", _wrap_cbf_handle_struct_set_divergence, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Float div_x_source,Float div_y_source,Float div_x_y_source\n"
		"\n"
		"C prototype: int cbf_set_divergence (cbf_handle handle, double div_x_source,\n"
		"                 double      div_y_source, double div_x_y_source);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_divergence sets the source divergence parameters to the \n"
		"values specified by div_x_source, div_y_source and div_x_y_source.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. div_x_source     New value of \n"
		"div_x_source. div_y_source     New value of div_y_source. \n"
		"div_x_y_source   New value of div_x_y_source.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_remove_datablock", _wrap_cbf_handle_struct_remove_datablock, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_datablock deletes the current data block. \n"
		"cbf_remove_saveframe deletes the current save frame.\n"
		"The current data block becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_count_elements", _wrap_cbf_handle_struct_count_elements, METH_VARARGS, (char *)"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_elements (cbf_handle handle,\n"
		"                 unsigned int *elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_elements sets *elements to the number of detector elements.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. elements   Pointer to the destination count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_image_fs", _wrap_cbf_handle_struct_set_image_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimfast,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_image_fs(cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimfast,\n"
		"                 size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_reference_detector", _wrap_cbf_handle_struct_require_reference_detector, METH_VARARGS, (char *)"\n"
		"Returns : pycbf detector object\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_require_reference_detector (cbf_handle handle,\n"
		"                 cbf_detector      *detector, unsigned int element_number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_detector constructs a detector object for detector \n"
		"element number element_number using the description in the CBF object \n"
		"handle and initialises the detector handle *detector.\n"
		"cbf_construct_reference_detector constructs a detector object for \n"
		"detector element number element_number using the description in the \n"
		"CBF object handle and initialises the detector handle *detector using \n"
		"the reference settings of the axes. cbf_require_reference_detector is \n"
		"similar, but try to force the creations of missing intermediate \n"
		"categories needed to construct a detector object.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. detector         Pointer to the \n"
		"destination detector handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_next_category", _wrap_cbf_handle_struct_next_category, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_category makes the category following the current category \n"
		"in the current data block the current category.\n"
		"If there are no more categories, the function returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_diffrn_id", _wrap_cbf_handle_struct_set_diffrn_id, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_diffrn_id (cbf_handle handle, const char *diffrn_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_diffrn_id sets the  \"diffrn.id \" entry of the current \n"
		"datablock to the ASCII value diffrn_id.\n"
		"This function also changes corresponding  \"diffrn_id \" entries in \n"
		"the  \"diffrn_source \",  \"diffrn_radiation \",  \"diffrn_detector \n"
		"\" and  \"diffrn_measurement \" categories.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. diffrn_id   ASCII value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_timestamp", _wrap_cbf_handle_struct_set_timestamp, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Float time,Integer timezone,Float precision\n"
		"\n"
		"C prototype: int cbf_set_timestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 double      time, int timezone, double precision);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_timestamp sets the collection timestamp in seconds since \n"
		"January 1 1970 to the value specified by time. The timezone \n"
		"difference from UTC\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_orientation_matrix", _wrap_cbf_handle_struct_get_orientation_matrix, METH_VARARGS, (char *)"\n"
		"Returns : Float matrix_0,Float matrix_1,Float matrix_2,Float matrix_3,\n"
		"          Float matrix_4,Float matrix_5,Float matrix_6,Float matrix_7,\n"
		"          Float matrix_8\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_orientation_matrix (cbf_handle handle,\n"
		"                 double ub_matrix[9]);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_orientation_matrix sets ub_matrix to point to the array of \n"
		"orientation matrix entries in the  \"diffrn \" category in the order \n"
		"of columns:\n"
		" \"UB[1][1] \"  \"UB[1][2] \"  \"UB[1][3] \"  \"UB[2][1] \"  \n"
		"\"UB[2][2] \"  \"UB[2][3] \"  \"UB[3][1] \"  \"UB[3][2] \"  \n"
		"\"UB[3][3] \"\n"
		"cbf_set_orientation_matrix sets the values in the  \"diffrn \" \n"
		"category to the values pointed to by ub_matrix.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. ubmatric   Source or destination array of 9 \n"
		"doubles giving the orientation matrix parameters.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_image_size_fs", _wrap_cbf_handle_struct_get_image_size_fs, METH_VARARGS, (char *)"\n"
		"Returns : size_t ndimfast,size_t ndimslow\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_image_size_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimfast, size_t *ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_divergence", _wrap_cbf_handle_struct_get_divergence, METH_VARARGS, (char *)"\n"
		"Returns : Float div_x_source,Float div_y_source,Float div_x_y_source\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_divergence (cbf_handle handle, double *div_x_source,\n"
		"                 double      *div_y_source, double *div_x_y_source);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_divergence sets *div_x_source, *div_y_source and \n"
		"*div_x_y_source to the corresponding source divergence parameters.\n"
		"Any of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. div_x_source     Pointer to the \n"
		"destination div_x_source. div_y_source     Pointer to the destination \n"
		"div_y_source. div_x_y_source   Pointer to the destination \n"
		"div_x_y_source.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_rewind_category", _wrap_cbf_handle_struct_rewind_category, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_category makes the first category in the current data \n"
		"block the current category. cbf_rewind_saveframe makes the first \n"
		"saveframe in the current data block the current saveframe. \n"
		"cbf_rewind_blockitem makes the first blockitem (category or \n"
		"saveframe) in the current data block the current blockitem. The type \n"
		"of the blockitem (CBF_CATEGORY or CBF_SAVEFRAME) is returned in type.\n"
		"If there are no categories, saveframes or blockitems the function \n"
		"returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. type     CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_read_template", _wrap_cbf_handle_struct_read_template, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String filename\n"
		"\n"
		"C prototype: int cbf_read_template (cbf_handle handle, FILE *file);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_read_template reads the CBF or CIF file file into the CBF object \n"
		"specified by handle and selects the first datablock as the current \n"
		"datablock.\n"
		"ARGUMENTS\n"
		"handle   Pointer to a CBF handle. file     Pointer to a file \n"
		"descriptor.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_select_row", _wrap_cbf_handle_struct_select_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_select_row (cbf_handle handle, unsigned int row);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_select_row selects row number row in the current category as the \n"
		"current row.\n"
		"The first row is number 0.\n"
		"The current column is not affected\n"
		"If the row does not exist, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. row      Number of the row to select.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_image_fs_as_string", _wrap_cbf_handle_struct_get_image_fs_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimfast,int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_image_fs (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimfast, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_image_size_sf", _wrap_cbf_handle_struct_get_image_size_sf, METH_VARARGS, (char *)"\n"
		"Returns : size_t ndimslow,size_t ndimfast\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_image_size_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimslow, size_t *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_real_image_fs_as_string", _wrap_cbf_handle_struct_get_real_image_fs_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimfast,int ndimslow\n"
		"\n"
		"C prototype: int cbf_get_real_image_fs (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimfast,\n"
		"                 size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_count_columns", _wrap_cbf_handle_struct_count_columns, METH_VARARGS, (char *)"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_columns (cbf_handle handle, unsigned int *columns);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_columns puts the number of columns in the current category \n"
		"in *columns.\n"
		"ARGUMENTS\n"
		"handle    CBF handle. columns   Pointer to the destination column \n"
		"count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integerarrayparameters_wdims", _wrap_cbf_handle_struct_get_integerarrayparameters_wdims, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement,char **bo,int *bolen,\n"
		"          int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters_wdims (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement, const    char **byteorder,\n"
		"                 size_t *dimfast, size_t *dimmid, size_t *dimslow,\n"
		"                 size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_gain", _wrap_cbf_handle_struct_get_gain, METH_VARARGS, (char *)"\n"
		"Returns : Float gain,Float gain_esd\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_gain (cbf_handle handle, unsigned int element_number,\n"
		"                 double      *gain, double *gain_esd);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_gain sets *gain and *gain_esd to the corresponding gain \n"
		"parameters for element number element_number.\n"
		"Either of the destination pointers may be NULL.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. gain             Pointer to the \n"
		"destination gain. gain_esd         Pointer to the destination \n"
		"gain_esd.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_new_saveframe", _wrap_cbf_handle_struct_new_saveframe, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_saveframe (cbf_handle handle,\n"
		"                 const char *saveframename);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_datablock creates a new data block with name datablockname \n"
		"and makes it the current data block. cbf_new_saveframe creates a new \n"
		"save frame with name saveframename within the current data block and \n"
		"makes the new save frame the current save frame.\n"
		"If a data block or save frame with this name already exists, the \n"
		"existing data block or save frame becomes the current data block or \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_polarization", _wrap_cbf_handle_struct_set_polarization, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Float polarizn_source_ratio,Float polarizn_source_norm\n"
		"\n"
		"C prototype: int cbf_set_polarization (cbf_handle handle,\n"
		"                 double      polarizn_source_ratio,\n"
		"                 double polarizn_source_norm);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_polarization sets the source polarization to the values \n"
		"specified by polarizn_source_ratio and polarizn_source_norm.\n"
		"ARGUMENTS\n"
		"handle                  CBF handle. polarizn_source_ratio   New value \n"
		"of polarizn_source_ratio. polarizn_source_norm    New value of \n"
		"polarizn_source_norm.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_real_3d_image", _wrap_cbf_handle_struct_set_real_3d_image, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_3d_image (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimslow, size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_delete_row", _wrap_cbf_handle_struct_delete_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_delete_row (cbf_handle handle, unsigned int rownumber);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_delete_row deletes a row from the current category. Rows starting \n"
		"from rownumber +1 are moved down by 1. If the current row was higher \n"
		"than rownumber, or if the current row is the last row, it will also \n"
		"move down by 1.\n"
		"The row numbers start from 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. rownumber   The number of the row to delete.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_column_name", _wrap_cbf_handle_struct_column_name, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_column_name (cbf_handle handle, const char **columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_column_name sets *columnname to point to the name of the current \n"
		"column of the current category.\n"
		"The column name will be valid as long as the column exists.\n"
		"The name must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   Pointer to the destination \n"
		"column name pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_remove_saveframe", _wrap_cbf_handle_struct_remove_saveframe, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_saveframe (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_datablock deletes the current data block. \n"
		"cbf_remove_saveframe deletes the current save frame.\n"
		"The current data block becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_integerarray_wdims_sf", _wrap_cbf_handle_struct_set_integerarray_wdims_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimslow,int dimmid,int dimfast,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_integerarray_wdims_sf (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, int elsigned,    size_t elements,\n"
		"                 const char *byteorder, size_t dimslow, size_t dimmid,\n"
		"                    size_t dimfast, size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_value", _wrap_cbf_handle_struct_require_value, METH_VARARGS, (char *)"\n"
		"Returns : String Value\n"
		"*args   : String defaultvalue\n"
		"\n"
		"C prototype: int cbf_require_value (cbf_handle handle, const char **value,\n"
		"                 const char    *defaultvalue );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_value sets *value to point to the ASCII value of the item at \n"
		"the current column and row. cbf_require_value sets *value to point to \n"
		"the ASCII value of the item at the current column and row, creating \n"
		"the data item if necessary and initializing it to a copy of \n"
		"defaultvalue.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"The value will be valid as long as the item exists and has not been \n"
		"set to a new value.\n"
		"The value must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. value          Pointer to the destination \n"
		"value pointer. defaultvalue   Default value character string.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_column_integervalue", _wrap_cbf_handle_struct_require_column_integervalue, METH_VARARGS, (char *)"\n"
		"Returns : Int Value\n"
		"*args   : String Columnvalue,Int default\n"
		"\n"
		"C prototype: int cbf_require_column_integervalue (cbf_handle handle,\n"
		"                 const char      *columnname, int *number,\n"
		"                 const int defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column_doublevalue sets *number to the value of the ASCII \n"
		"item at the current row for the column given with the name given by \n"
		"*columnname, with the value interpreted as an integer number, or to \n"
		"the number given by defaultvalue if the item cannot be found.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. columnname     Name of the column \n"
		"containing the number. number         pointer to the location to \n"
		"receive the integer value. defaultvalue   Value to use if the \n"
		"requested column and value cannot be found.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_pixel_size", _wrap_cbf_handle_struct_set_pixel_size, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Int element_number,Int axis_number,Float pixel size\n"
		"\n"
		"C prototype: int cbf_set_pixel_size (cbf_handle handle,\n"
		"                 unsigned int element_number,      int axis_number,\n"
		"                 double psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_pixel_size and cbf_set_pixel_size_sf set the item in the \n"
		"&quote;size&quote; column of the  \"array_structure_list \" category \n"
		"at the row which matches axis axis_number of the detector element \n"
		"element_number converting the double pixel size psize from meters to \n"
		"millimeters in storing it in the  \"size \" column for the axis \n"
		"axis_number of the detector element element_number. The axis_number \n"
		"is numbered from 1, starting with the slowest axis. \n"
		"cbf_set_pixel_size_fs sets the item\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_next_column", _wrap_cbf_handle_struct_next_column, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_column (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_column makes the column following the current column in the \n"
		"current category the current column.\n"
		"If there are no more columns, the function returns CBF_NOTFOUND.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_3d_image_size_sf", _wrap_cbf_handle_struct_get_3d_image_size_sf, METH_VARARGS, (char *)"\n"
		"Returns : size_t ndimslow,size_t ndimmid,size_t ndimfast\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_3d_image_size_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimslow, size_t *ndimmid, size_t      *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_realarrayparameters_wdims_fs", _wrap_cbf_handle_struct_get_realarrayparameters_wdims_fs, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elements,char **bo,\n"
		"          int *bolen,int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters_wdims_fs (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements, const char    **byteorder, size_t *dimfast,\n"
		"                 size_t *dimmid, size_t *dimslow, size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_realarray_as_string", _wrap_cbf_handle_struct_get_realarray_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarray (cbf_handle handle, int *binary_id,\n"
		"                 void *array,    size_t elsize, size_t elements,\n"
		"                 size_t *elements_read);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarray reads the binary value of the item at the \n"
		"current column and row into an integer array. The array consists of \n"
		"elements elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsigned is non-0 and unsigned otherwise. \n"
		"*binary_id is set to the binary section identifier and *elements_read \n"
		"to the number of elements actually read. cbf_get_realarray reads the \n"
		"binary value of the item at the current column and row into a real \n"
		"array. The array consists of elements elements of elsize bytes each, \n"
		"starting at array. *binary_id is set to the binary section identifier \n"
		"and *elements_read to the number of elements actually read.\n"
		"If any element in the integer binary data cant fit into the \n"
		"destination element, the destination is set the nearest possible \n"
		"value.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"If the requested number of elements cant be read, the function will \n"
		"read as many as it can and then return CBF_ENDOFDATA.\n"
		"Currently, the destination array must consist of chars, shorts or \n"
		"ints (signed or unsigned). If elsize is not equal to sizeof (char), \n"
		"sizeof (short) or sizeof (int), for cbf_get_integerarray, or \n"
		"sizeof(double) or sizeof(float), for cbf_get_realarray the function \n"
		"returns CBF_ARGUMENT.\n"
		"An additional restriction in the current version of CBFlib is that \n"
		"values too large to fit in an int are not correctly decompressed. As \n"
		"an example, if the machine with 32-bit ints is reading an array \n"
		"containing a value outside the range 0 .. 2^32-1 (unsigned) or -2^31 \n"
		".. 2^31-1 (signed), the array will not be correctly decompressed. \n"
		"This restriction will be removed in a future release. For \n"
		"cbf_get_realarray, only IEEE format is supported. No conversion to \n"
		"other floating point formats is done at this time.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. binary_id       Pointer to the \n"
		"destination integer binary identifier. array           Pointer to the \n"
		"destination array. elsize          Size in bytes of each destination \n"
		"array element. elsigned        Set to non-0 if the destination array \n"
		"elements are signed. elements        The number of elements to read. \n"
		"elements_read   Pointer to the destination number of elements \n"
		"actually read.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_bin_sizes", _wrap_cbf_handle_struct_get_bin_sizes, METH_VARARGS, (char *)"\n"
		"Returns : Float slowbinsize,Float fastbinsize\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_bin_sizes(cbf_handle handle,\n"
		"                 unsigned int element_number,      double * slowbinsize,\n"
		"                 double * fastbinsize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_bin_sizes sets slowbinsize to point to the value of the \n"
		"number of pixels composing one array element in the dimension that \n"
		"changes at the second-fastest rate and fastbinsize to point to the \n"
		"value of the number of pixels composing one array element in the \n"
		"dimension that changes at the fastest rate for the dectector element \n"
		"with the ordinal element_number. cbf_set_bin_sizes sets the the pixel \n"
		"bin sizes in the  \"array_intensities \" category to the values of \n"
		"slowbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the second-fastest rate and \n"
		"fastbinsize_in for the number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate for the dectector \n"
		"element with the ordinal element_number.\n"
		"In order to allow for software binning involving fractions of pixels, \n"
		"the bin sizes are doubles rather than ints.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. slowbinsize      Pointer to the \n"
		"returned number of pixels composing one array element in the \n"
		"dimension that changes at the second-fastest rate. fastbinsize      \n"
		"Pointer to the returned number of pixels composing one array element \n"
		"in the dimension that changes at the fastest rate. slowbinsize_in   \n"
		"The number of pixels composing one array element in the dimension \n"
		"that changes at the second-fastest rate. fastbinsize_in   The number \n"
		"of pixels composing one array element in the dimension that changes \n"
		"at the fastest rate.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_reset_category", _wrap_cbf_handle_struct_reset_category, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_category deletes all columns and rows from current category.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_construct_goniometer", _wrap_cbf_handle_struct_construct_goniometer, METH_VARARGS, (char *)"\n"
		"Returns : pycbf goniometer object\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_construct_goniometer (cbf_handle handle,\n"
		"                 cbf_goniometer      *goniometer);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_construct_goniometer constructs a goniometer object using the \n"
		"description in the CBF object handle and initialises the goniometer \n"
		"handle *goniometer.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. goniometer   Pointer to the destination \n"
		"goniometer handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_datablockname", _wrap_cbf_handle_struct_set_datablockname, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_datablockname (cbf_handle handle,\n"
		"                 const char *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_datablockname changes the name of the current data block to \n"
		"datablockname. cbf_set_saveframename changes the name of the current \n"
		"save frame to saveframename.\n"
		"If a data block or save frame with this name already exists \n"
		"(comparison is case-insensitive), the function returns CBF_IDENTICAL.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The new data block name. \n"
		"datablockname   The new save frame name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_crystal_id", _wrap_cbf_handle_struct_set_crystal_id, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_crystal_id (cbf_handle handle,\n"
		"                 const char *crystal_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_crystal_id sets the  \"diffrn.crystal_id \" entry to the \n"
		"ASCII value crystal_id.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. crystal_id   ASCII value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integerarray_as_string", _wrap_cbf_handle_struct_get_integerarray_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarray (cbf_handle handle, int *binary_id,\n"
		"                 void *array,    size_t elsize, int elsigned, size_t elements,\n"
		"                 size_t *elements_read);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarray reads the binary value of the item at the \n"
		"current column and row into an integer array. The array consists of \n"
		"elements elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsigned is non-0 and unsigned otherwise. \n"
		"*binary_id is set to the binary section identifier and *elements_read \n"
		"to the number of elements actually read. cbf_get_realarray reads the \n"
		"binary value of the item at the current column and row into a real \n"
		"array. The array consists of elements elements of elsize bytes each, \n"
		"starting at array. *binary_id is set to the binary section identifier \n"
		"and *elements_read to the number of elements actually read.\n"
		"If any element in the integer binary data cant fit into the \n"
		"destination element, the destination is set the nearest possible \n"
		"value.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"If the requested number of elements cant be read, the function will \n"
		"read as many as it can and then return CBF_ENDOFDATA.\n"
		"Currently, the destination array must consist of chars, shorts or \n"
		"ints (signed or unsigned). If elsize is not equal to sizeof (char), \n"
		"sizeof (short) or sizeof (int), for cbf_get_integerarray, or \n"
		"sizeof(double) or sizeof(float), for cbf_get_realarray the function \n"
		"returns CBF_ARGUMENT.\n"
		"An additional restriction in the current version of CBFlib is that \n"
		"values too large to fit in an int are not correctly decompressed. As \n"
		"an example, if the machine with 32-bit ints is reading an array \n"
		"containing a value outside the range 0 .. 2^32-1 (unsigned) or -2^31 \n"
		".. 2^31-1 (signed), the array will not be correctly decompressed. \n"
		"This restriction will be removed in a future release. For \n"
		"cbf_get_realarray, only IEEE format is supported. No conversion to \n"
		"other floating point formats is done at this time.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. binary_id       Pointer to the \n"
		"destination integer binary identifier. array           Pointer to the \n"
		"destination array. elsize          Size in bytes of each destination \n"
		"array element. elsigned        Set to non-0 if the destination array \n"
		"elements are signed. elements        The number of elements to read. \n"
		"elements_read   Pointer to the destination number of elements \n"
		"actually read.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_3d_image", _wrap_cbf_handle_struct_set_3d_image, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_3d_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_dictionary", _wrap_cbf_handle_struct_set_dictionary, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : CBFHandle dictionary\n"
		"\n"
		"C prototype: int cbf_set_dictionary (cbf_handle handle,\n"
		"                 cbf_handle dictionary_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_dictionary sets *dictionary to the handle of a CBF which has \n"
		"been associated with the CBF handle by cbf_set_dictionary. \n"
		"cbf_set_dictionary associates the CBF handle dictionary_in with \n"
		"handle as its dictionary. cbf_require_dictionary sets *dictionary to \n"
		"the handle of a CBF which has been associated with the CBF handle by \n"
		"cbf_set_dictionary or creates a new empty CBF and associates it with \n"
		"handle, returning the new handle in *dictionary.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. dictionary      Pointer to CBF handle of \n"
		"dictionary. dictionary_in   CBF handle of dcitionary.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_tag_category", _wrap_cbf_handle_struct_find_tag_category, METH_VARARGS, (char *)"\n"
		"Returns : String categoryname\n"
		"*args   : String tagname\n"
		"\n"
		"C prototype: int cbf_find_tag_category (cbf_handle handle,\n"
		"                 const char* tagname, const      char** categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_category sets categoryname to the category associated \n"
		"with tagname in the dictionary associated with handle. \n"
		"cbf_set_tag_category upddates the dictionary associated with handle \n"
		"to indicated that tagname is in category categoryname_in.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. tagname           tag name. \n"
		"categoryname      pointer to a returned category name. \n"
		"categoryname_in   input category name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_real_3d_image_sf_as_string", _wrap_cbf_handle_struct_get_real_3d_image_sf_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimmid,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_3d_image_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_typeofvalue", _wrap_cbf_handle_struct_set_typeofvalue, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_typeofvalue (cbf_handle handle,\n"
		"                 const char *typeofvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_typeofvalue sets the type of the item at the current column \n"
		"and row to the type specified by the ASCII character string given by \n"
		"typeofvalue. The strings that may be used are:\n"
		" \"null \" for a null value indicated by a  \". \" or a  \"? \"  \n"
		"\"bnry \" for a binary value  \"word \" for an unquoted string  \n"
		"\"dblq \" for a double-quoted string  \"sglq \" for a single-quoted \n"
		"string  \"text \" for a semicolon-quoted string (multiline text \n"
		"field)  \"prns \" for a parenthesis-bracketed string (multiline text \n"
		"field)  \"brcs \" for a brace-bracketed string (multiline text field) \n"
		" \"bkts \" for a square-bracket-bracketed string (multiline text \n"
		"field)  \"tsqs \" for a treble-single-quote quoted string (multiline \n"
		"text field)  \"tdqs \" for a treble-double-quote quoted string \n"
		"(multiline text field)\n"
		"Not all types may be used for all values. Not all types are valid for \n"
		"all type of CIF files. In partcular the types  \"prns \",  \"brcs \", \n"
		" \"bkts \" were introduced with DDLm and are not valid in DDL1 or \n"
		"DDL2 CIFS. The types  \"tsqs \" and  \"tdqs \" are not formally part \n"
		"of the CIF syntax. No changes may be made to the type of binary \n"
		"values. You may not set the type of a string that contains a single \n"
		"quote followed by a blank or a tab or which contains multiple lines \n"
		"to  \"sglq \". You may not set the type of a string that contains a \n"
		"double quote followed by a blank or a tab or which contains multiple \n"
		"lines to  \"dblq \".\n"
		"ARGUMENTS\n"
		"handle        CBF handle. typeofvalue   ASCII string for desired type \n"
		"of value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_integerarray_wdims", _wrap_cbf_handle_struct_set_integerarray_wdims, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimfast,int dimmid,int dimslow,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_integerarray_wdims (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, int elsigned,    size_t elements,\n"
		"                 const char *byteorder, size_t dimfast, size_t dimmid,\n"
		"                    size_t dimslow, size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_integration_time", _wrap_cbf_handle_struct_set_integration_time, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Float time\n"
		"\n"
		"C prototype: int cbf_set_integration_time (cbf_handle handle,\n"
		"                 unsigned int reserved,      double time);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integration_time sets the integration time in seconds to the \n"
		"value specified by time. The parameter reserved is presently unused \n"
		"and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle             CBF handle. reserved           Unused. Any value \n"
		"other than 0 is invalid. time Integration   time in seconds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_axis_setting", _wrap_cbf_handle_struct_set_axis_setting, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String axis_id,Float start,Float increment\n"
		"\n"
		"C prototype: int cbf_set_axis_setting (cbf_handle handle,\n"
		"                 unsigned int reserved,      const char *axis_id, double start,\n"
		"                 double increment);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_axis_setting sets the starting and increment values of the \n"
		"axis axis_id to start and increment.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. reserved    Unused. Any value other than 0 is \n"
		"invalid. axis_id     Axis id. start       Start value. increment   \n"
		"Increment value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_real_image_as_string", _wrap_cbf_handle_struct_get_real_image_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_image (cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, void *array, size_t elsize,\n"
		"                 size_t      ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_3d_image_sf_as_string", _wrap_cbf_handle_struct_get_3d_image_sf_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimmid,\n"
		"          int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_3d_image_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, int elsign,      size_t ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_real_image_fs", _wrap_cbf_handle_struct_set_real_image_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimfast,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_real_image_fs(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimfast, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_overload", _wrap_cbf_handle_struct_get_overload, METH_VARARGS, (char *)"\n"
		"Returns : Float overload\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_overload (cbf_handle handle,\n"
		"                 unsigned int element_number,      double *overload);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_overload sets *overload to the overload value for element \n"
		"number element_number.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. overload         Pointer to the \n"
		"destination overload.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_wavelength", _wrap_cbf_handle_struct_get_wavelength, METH_VARARGS, (char *)"\n"
		"Returns : double\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_wavelength (cbf_handle handle, double *wavelength);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_wavelength sets *wavelength to the current wavelength in AA.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. wavelength   Pointer to the destination.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_next_datablock", _wrap_cbf_handle_struct_next_datablock, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_datablock makes the data block following the current data \n"
		"block the current data block.\n"
		"If there are no more data blocks, the function returns CBF_NOTFOUND.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_realarrayparameters_wdims", _wrap_cbf_handle_struct_get_realarrayparameters_wdims, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elements,char **bo,\n"
		"          int *bolen,int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_realarrayparameters_wdims (cbf_handle handle,\n"
		"                 unsigned int    *compression, int *binary_id, size_t *elsize,\n"
		"                 size_t *elements, const char    **byteorder, size_t *dimfast,\n"
		"                 size_t *dimmid, size_t *dimslow, size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_orientation_matrix", _wrap_cbf_handle_struct_set_orientation_matrix, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Float matrix_0,Float matrix_1,Float matrix_2,Float matrix_3,\n"
		"          Float matrix_4,Float matrix_5,Float matrix_6,Float matrix_7,\n"
		"          Float matrix_8\n"
		"\n"
		"C prototype: int cbf_set_orientation_matrix (cbf_handle handle,\n"
		"                 double ub_matrix[9]);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_orientation_matrix sets ub_matrix to point to the array of \n"
		"orientation matrix entries in the  \"diffrn \" category in the order \n"
		"of columns:\n"
		" \"UB[1][1] \"  \"UB[1][2] \"  \"UB[1][3] \"  \"UB[2][1] \"  \n"
		"\"UB[2][2] \"  \"UB[2][3] \"  \"UB[3][1] \"  \"UB[3][2] \"  \n"
		"\"UB[3][3] \"\n"
		"cbf_set_orientation_matrix sets the values in the  \"diffrn \" \n"
		"category to the values pointed to by ub_matrix.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. ubmatric   Source or destination array of 9 \n"
		"doubles giving the orientation matrix parameters.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_new_category", _wrap_cbf_handle_struct_new_category, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_category creates a new category in the current data block \n"
		"with name categoryname and makes it the current category.\n"
		"If a category with this name already exists, the existing category \n"
		"becomes the current category.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the new \n"
		"category.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_gain", _wrap_cbf_handle_struct_set_gain, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Float gain,Float gain_esd\n"
		"\n"
		"C prototype: int cbf_set_gain (cbf_handle handle, unsigned int element_number,\n"
		"                 double      gain, double gain_esd);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_gain sets the gain of element number element_number to the \n"
		"values specified by gain and gain_esd.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. gain             New gain value. \n"
		"gain_esd         New gain_esd value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_column", _wrap_cbf_handle_struct_find_column, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_column (cbf_handle handle, const char *columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_column makes the columns in the current category with name \n"
		"columnname the current column.\n"
		"The comparison is case-insensitive.\n"
		"If the column does not exist, the function returns CBF_NOTFOUND.\n"
		"The current row is not affected.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   The name of column to find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_remove_category", _wrap_cbf_handle_struct_remove_category, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_category (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_category deletes the current category.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integerarrayparameters_wdims_sf", _wrap_cbf_handle_struct_get_integerarrayparameters_wdims_sf, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement,char **bo,int *bolen,\n"
		"          int dimslow,int dimmid,int dimfast,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters_wdims_sf (cbf_handle handle,\n"
		"                 unsigned    int *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement, const    char **byteorder,\n"
		"                 size_t *dimslow, size_t *dimmid, size_t *dimfast,\n"
		"                 size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_pixel_size", _wrap_cbf_handle_struct_get_pixel_size, METH_VARARGS, (char *)"\n"
		"Returns : Float pixel_size\n"
		"*args   : Int element_number,Int axis_number\n"
		"\n"
		"C prototype: int cbf_get_pixel_size (cbf_handle handle,\n"
		"                 unsigned int element_number,      int axis_number,\n"
		"                 double *psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_pixel_size and cbf_get_pixel_size_sf set *psize to point to \n"
		"the double value in millimeters of the axis axis_number of the \n"
		"detector element element_number. The axis_number is numbered from 1, \n"
		"starting with the slowest axis. cbf_get_pixel_size_fs sets *psize to \n"
		"point to the double value in millimeters of the axis axis_number of \n"
		"the detector element element_number. The axis_number is numbered from \n"
		"1, starting with the fastest axis.\n"
		"If a negative axis number is given, the order of axes is reversed, so \n"
		"that -1 specifies the slowest axis for cbf_get_pixel_size_fs and the \n"
		"fastest axis for cbf_get_pixel_size_sf.\n"
		"If the pixel size is not given explcitly in the  \"array_element_size \n"
		"\" category, the function returns CBF_NOTFOUND.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. axis_number      The number of the \n"
		"axis, starting from 1 for the fastest for cbf_get_pixel_size and \n"
		"cbf_get_pixel_size_fs and the slowest for cbf_get_pixel_size_sf. \n"
		"psize            Pointer to the destination pixel size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_real_image_sf", _wrap_cbf_handle_struct_set_real_image_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_image_sf(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_category", _wrap_cbf_handle_struct_require_category, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_require_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewuire_category makes the category in the current data block \n"
		"with name categoryname the current category, if it exists, or creates \n"
		"the catagory if it does not exist.\n"
		"The comparison is case-insensitive.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the category to \n"
		"find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_reciprocal_cell", _wrap_cbf_handle_struct_get_reciprocal_cell, METH_VARARGS, (char *)"\n"
		"Returns : Float astar,Float bstar,Float cstar,Float alphastar,Float betastar,\n"
		"          Float gammastar\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_reciprocal_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_reciprocal_cell sets cell[0:2] to the double values of the \n"
		"reciprocal cell edge lengths a*, b* and c* in AAngstroms-1, cell[3:5] \n"
		"to the double values of the reciprocal cell angles a*, b* and g* in \n"
		"degrees, cell_esd[0:2] to the double values of the estimated \n"
		"strandard deviations of the reciprocal cell edge lengths a*, b* and \n"
		"c* in AAngstroms-1, cell_esd[3:5] to the double values of the \n"
		"estimated standard deviations of the the reciprocal cell angles a*, \n"
		"b* and g* in degrees.\n"
		"The values returned are retrieved from the first row of the  \"cell \n"
		"\" category. The value of  \"_cell.entry_id \" is ignored.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the reciprocal cell parameters are not retrieved.\n"
		"If cell_esd is NULL, the reciprocal cell parameter esds are not \n"
		"retrieved.\n"
		"If the  \"cell \" category is present, but some of the values are \n"
		"missing, zeros are returned for the missing values.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the destination array of \n"
		"6 doubles for the reciprocal cell parameters. cell_esd   Pointer to \n"
		"the destination array of 6 doubles for the reciprocal cell parameter \n"
		"esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success. No errors is \n"
		"returned for missing values if the  \"cell \" category exists.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_reciprocal_cell_esd", _wrap_cbf_handle_struct_get_reciprocal_cell_esd, METH_VARARGS, (char *)"cbf_handle_struct_get_reciprocal_cell_esd(cbf_handle_struct self)"},
	 { (char *)"cbf_handle_struct_get_3d_image_size", _wrap_cbf_handle_struct_get_3d_image_size, METH_VARARGS, (char *)"\n"
		"Returns : size_t ndimslow,size_t ndimmid,size_t ndimfast\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_3d_image_size (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 size_t *ndimslow, size_t *ndimmid, size_t      *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_tag_root", _wrap_cbf_handle_struct_find_tag_root, METH_VARARGS, (char *)"\n"
		"Returns : String tagroot\n"
		"*args   : String tagname\n"
		"\n"
		"C prototype: int cbf_find_tag_root (cbf_handle handle, const char* tagname,\n"
		"                 const      char** tagroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_root sets *tagroot to the root tag of which tagname is \n"
		"an alias. cbf_set_tag_root sets tagname as an alias of tagroot_in in \n"
		"the dictionary associated with handle, creating the dictionary if \n"
		"necessary. cbf_require_tag_root sets *tagroot to the root tag of \n"
		"which tagname is an alias, if there is one, or to the value of \n"
		"tagname, if tagname is not an alias.\n"
		"A returned tagroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. tagname      tag name which may be an alias. \n"
		"tagroot      pointer to a returned tag root name. tagroot_in   input \n"
		"tag root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_category_root", _wrap_cbf_handle_struct_require_category_root, METH_VARARGS, (char *)"cbf_handle_struct_require_category_root(cbf_handle_struct self, char categoryname) -> char"},
	 { (char *)"cbf_handle_struct_set_realarray_wdims_sf", _wrap_cbf_handle_struct_set_realarray_wdims_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimslow,int dimmid,int dimfast,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_realarray_wdims_sf (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, size_t elements,    const char *byteorder,\n"
		"                 size_t dimslow, size_t dimmid, size_t dimfast,\n"
		"                    size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_integervalue", _wrap_cbf_handle_struct_set_integervalue, METH_VARARGS, (char *)"\n"
		"Returns : int number\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_integervalue (cbf_handle handle, int number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integervalue sets the item at the current column and row to \n"
		"the integer value number written as a decimal ASCII string.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. number   Integer value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_category_name", _wrap_cbf_handle_struct_category_name, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_category_name (cbf_handle handle,\n"
		"                 const char **categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_category_name sets *categoryname to point to the name of the \n"
		"current category of the current data block.\n"
		"The category name will be valid as long as the category exists.\n"
		"The name must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   Pointer to the destination \n"
		"category name pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_typeofvalue", _wrap_cbf_handle_struct_get_typeofvalue, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : string\n"
		"\n"
		"C prototype: int cbf_get_typeofvalue (cbf_handle handle,\n"
		"                 const char **typeofvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_value sets *typeofvalue to point an ASCII descriptor of the \n"
		"value of the item at the current column and row. The strings that may \n"
		"be returned are:\n"
		" \"null \" for a null value indicated by a  \". \" or a  \"? \"  \n"
		"\"bnry \" for a binary value  \"word \" for an unquoted string  \n"
		"\"dblq \" for a double-quoted string  \"sglq \" for a single-quoted \n"
		"string  \"text \" for a semicolon-quoted string (multiline text \n"
		"field)  \"prns \" for a parenthesis-bracketed string (multiline text \n"
		"field)  \"brcs \" for a brace-bracketed string (multiline text field) \n"
		" \"bkts \" for a square-bracket-bracketed string (multiline text \n"
		"field)  \"tsqs \" for a treble-single-quote quoted string (multiline \n"
		"text field)  \"tdqs \" for a treble-double-quote quoted string \n"
		"(multiline text field)\n"
		"Not all types are valid for all type of CIF files. In partcular the \n"
		"types  \"prns \",  \"brcs \",  \"bkts \" were introduced with DDLm \n"
		"and are not valid in DDL1 or DDL2 CIFS. The types  \"tsqs \" and  \n"
		"\"tdqs \" are not formally part of the CIF syntax. A field for which \n"
		"no value has been set sets *typeofvalue to NULL rather than to the \n"
		"string  \"null \".\n"
		"The typeofvalue must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. typeofvalue   Pointer to the destination \n"
		"type-of-value string pointer.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_real_image", _wrap_cbf_handle_struct_set_real_image, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_real_image (cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, unsigned int compression,\n"
		"                 void      *array,size_t elsize, size_t ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_3d_image_as_string", _wrap_cbf_handle_struct_get_3d_image_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimmid,\n"
		"          int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_3d_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimslow, size_t ndimmid,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_remove_row", _wrap_cbf_handle_struct_remove_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_remove_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_remove_row deletes the current row in the current category.\n"
		"If the current row was the last row, it will move down by 1, \n"
		"otherwise, it will remain the same.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_overload", _wrap_cbf_handle_struct_set_overload, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer element_number,Float overload\n"
		"\n"
		"C prototype: int cbf_set_overload (cbf_handle handle,\n"
		"                 unsigned int element_number,      double overload);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_overload sets the overload value of element number \n"
		"element_number to overload.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. overload         New overload value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_image_size", _wrap_cbf_handle_struct_get_image_size, METH_VARARGS, (char *)"\n"
		"Returns : size_t ndim1,size_t ndim2\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_image_size (cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, size_t *ndimslow,\n"
		"                 size_t *ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image_size, cbf_get_image_size_fs and cbf_get_image_size_sf \n"
		"set *ndimslow and *ndimfast to the slow and fast dimensions of the \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimfast \n"
		"will be set to 1. If the array is 3-dimensional an error code will be \n"
		"returned. cbf_get_3d_image_size, cbf_get_3d_image_size_fs and \n"
		"cbf_get_3d_image_size_sf set *ndimslow, *ndimmid and *ndimfast to the \n"
		"slowest, next fastest and fastest dimensions, respectively, of the 3D \n"
		"image array for element number element_number. If the array is \n"
		"1-dimensional, *ndimslow will be set to the array size and *ndimmid \n"
		"and\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_3d_image_sf", _wrap_cbf_handle_struct_set_3d_image_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimmid,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_3d_image_sf(cbf_handle handle, unsigned int reserved,\n"
		"                      unsigned int element_number, unsigned int compression,\n"
		"                 void *array,      size_t elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimmid, size_t      ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_real_image_sf_as_string", _wrap_cbf_handle_struct_get_real_image_sf_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_image_sf (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_image_as_string", _wrap_cbf_handle_struct_get_image_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_image (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_tag_root", _wrap_cbf_handle_struct_set_tag_root, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String tagname,String tagroot_in\n"
		"\n"
		"C prototype: int cbf_set_tag_root (cbf_handle handle, const char* tagname,\n"
		"                 const      char*tagroot_in);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_tag_root sets *tagroot to the root tag of which tagname is \n"
		"an alias. cbf_set_tag_root sets tagname as an alias of tagroot_in in \n"
		"the dictionary associated with handle, creating the dictionary if \n"
		"necessary. cbf_require_tag_root sets *tagroot to the root tag of \n"
		"which tagname is an alias, if there is one, or to the value of \n"
		"tagname, if tagname is not an alias.\n"
		"A returned tagroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. tagname      tag name which may be an alias. \n"
		"tagroot      pointer to a returned tag root name. tagroot_in   input \n"
		"tag root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_write_widefile", _wrap_cbf_handle_struct_write_widefile, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String filename,Integer ciforcbf,Integer Headers,Integer encoding\n"
		"\n"
		"C prototype: int cbf_write_widefile (cbf_handle handle, FILE *file,\n"
		"                 int readable, int    ciforcbf, int flags, int encoding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_write_file writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.0 conventions of 80 character lines. \n"
		"cbf_write_widefile writes the CBF object specified by handle into the \n"
		"file file, following CIF 1.1 conventions of 2048 character lines. A \n"
		"warning is issued to stderr for ascii lines over the limit, and an \n"
		"attempt is made to fold lines to fit. No test is performed on binary \n"
		"sections.\n"
		"If a dictionary has been provided, aliases will be applied on output.\n"
		"Unlike cbf_read_file, the file does not have to be random-access.\n"
		"If the file is random-access and readable, readable can be set to \n"
		"non-0 to indicate to CBFlib that the file can be used as a buffer to \n"
		"conserve disk space. If the file is not random-access or not \n"
		"readable, readable must be 0.\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_count_rows", _wrap_cbf_handle_struct_count_rows, METH_VARARGS, (char *)"\n"
		"Returns : Integer\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_count_rows (cbf_handle handle, unsigned int *rows);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_count_rows puts the number of rows in the current category in \n"
		"*rows .\n"
		"ARGUMENTS\n"
		"handle   CBF handle. rows     Pointer to the destination row count.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_datablock", _wrap_cbf_handle_struct_require_datablock, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_require_datablock (cbf_handle handle,\n"
		"                 const char      *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_datablock makes the data block with name datablockname \n"
		"the current data block, if it exists, or creates it if it does not.\n"
		"The comparison is case-insensitive.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the data \n"
		"block to find or create.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_integerarray", _wrap_cbf_handle_struct_set_integerarray, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elsigned,int elements\n"
		"\n"
		"C prototype: int cbf_set_integerarray (cbf_handle handle,\n"
		"                 unsigned int compression, int    binary_id, void *array,\n"
		"                 size_t elsize, int elsigned, size_t elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_new_datablock", _wrap_cbf_handle_struct_new_datablock, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_datablock (cbf_handle handle,\n"
		"                 const char *datablockname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_datablock creates a new data block with name datablockname \n"
		"and makes it the current data block. cbf_new_saveframe creates a new \n"
		"save frame with name saveframename within the current data block and \n"
		"makes the new save frame the current save frame.\n"
		"If a data block or save frame with this name already exists, the \n"
		"existing data block or save frame becomes the current data block or \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. datablockname   The name of the new data \n"
		"block. saveframename   The name of the new save frame.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_datestamp", _wrap_cbf_handle_struct_set_datestamp, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int year,int month,int day,int hour,int minute,double second,\n"
		"          int timezone,Float precision\n"
		"\n"
		"C prototype: int cbf_set_datestamp (cbf_handle handle, unsigned int reserved,\n"
		"                 int      year, int month, int day, int hour, int minute,\n"
		"                 double second, int      timezone, double precision);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_datestamp sets the collection timestamp in seconds since \n"
		"January 1 1970 to the value specified by time. The timezone \n"
		"difference from UTC\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_next_row", _wrap_cbf_handle_struct_next_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_next_row (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_next_row makes the row following the current row in the current \n"
		"category the current row.\n"
		"If there are no more rows, the function returns CBF_NOTFOUND.\n"
		"The current column is not affected.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_category_root", _wrap_cbf_handle_struct_set_category_root, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String categoryname,String categoryroot\n"
		"\n"
		"C prototype: int cbf_set_category_root (cbf_handle handle,\n"
		"                 const char*      categoryname_in, const char*categoryroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias. cbf_set_category_root sets \n"
		"categoryname_in as an alias of categoryroot in the dictionary \n"
		"associated with handle, creating the dictionary if necessary. \n"
		"cbf_require_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias, if there is one, or to the value of \n"
		"categoryname, if categoryname is not an alias.\n"
		"A returned categoryroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. categoryname      category name which \n"
		"may be an alias. categoryroot      pointer to a returned category \n"
		"root name. categoryroot_in   input category root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_pixel_size_fs", _wrap_cbf_handle_struct_set_pixel_size_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Int element_number,Int axis_number,Float pixel size\n"
		"\n"
		"C prototype: int cbf_set_pixel_size_fs(cbf_handle handle,\n"
		"                 unsigned int      element_number, int axis_number,\n"
		"                 double psize);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_pixel_size and cbf_set_pixel_size_sf set the item in the \n"
		"&quote;size&quote; column of the  \"array_structure_list \" category \n"
		"at the row which matches axis axis_number of the detector element \n"
		"element_number converting the double pixel size psize from meters to \n"
		"millimeters in storing it in the  \"size \" column for the axis \n"
		"axis_number of the detector element element_number. The axis_number \n"
		"is numbered from 1, starting with the slowest axis. \n"
		"cbf_set_pixel_size_fs sets the item\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_insert_row", _wrap_cbf_handle_struct_insert_row, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer\n"
		"\n"
		"C prototype: int cbf_insert_row (cbf_handle handle, unsigned int rownumber);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_insert_row adds a new row to the current category. The new row is \n"
		"inserted as row rownumber and existing rows starting from rownumber \n"
		"are moved up by 1. The new row becomes the current row.\n"
		"If the category has fewer than rownumber rows, the function returns \n"
		"CBF_NOTFOUND.\n"
		"The row numbers start from 0.\n"
		"ARGUMENTS\n"
		"handle      CBF handle. rownumber   The row number of the new row.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_new_column", _wrap_cbf_handle_struct_new_column, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_new_column (cbf_handle handle, const char *columnname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_new_column creates a new column in the current category with name \n"
		"columnname and makes it the current column.\n"
		"If a column with this name already exists, the existing column \n"
		"becomes the current category.\n"
		"ARGUMENTS\n"
		"handle       CBF handle. columnname   The name of the new column.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_real_3d_image_as_string", _wrap_cbf_handle_struct_get_real_3d_image_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int ndimslow,int ndimmid,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_real_3d_image (cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 void *array, size_t elsize, size_t      ndimslow,\n"
		"                 size_t ndimmid, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integration_time", _wrap_cbf_handle_struct_get_integration_time, METH_VARARGS, (char *)"\n"
		"Returns : Float time\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integration_time (cbf_handle handle,\n"
		"                 unsigned int reserved,      double *time);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integration_time sets *time to the integration time in \n"
		"seconds. The parameter reserved is presently unused and should be set \n"
		"to 0.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused. Any value other than 0 is \n"
		"invalid. time       Pointer to the destination time.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_realarray", _wrap_cbf_handle_struct_set_realarray, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements\n"
		"\n"
		"C prototype: int cbf_set_realarray (cbf_handle handle,\n"
		"                 unsigned int compression, int    binary_id, void *array,\n"
		"                 size_t elsize, size_t elements);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_element_id", _wrap_cbf_handle_struct_get_element_id, METH_VARARGS, (char *)"\n"
		"Returns : String\n"
		"*args   : Integer element_number\n"
		"\n"
		"C prototype: int cbf_get_element_id (cbf_handle handle,\n"
		"                 unsigned int element_number,      const char **element_id);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_element_id sets *element_id to point to the ASCII value of \n"
		"the element_number'th  \"diffrn_data_frame.detector_element_id \" \n"
		"entry, counting from 0.\n"
		"If the detector element does not exist, the function returns \n"
		"CBF_NOTFOUND.\n"
		"The element_id will be valid as long as the item exists and has not \n"
		"been set to a new value.\n"
		"The element_id must not be modified by the program in any way.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. element_number   The number of the \n"
		"detector element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. element_id       Pointer to the \n"
		"destination.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_image_sf_as_string", _wrap_cbf_handle_struct_get_image_sf_as_string, METH_VARARGS, (char *)"\n"
		"Returns : (Binary)String\n"
		"*args   : int element_number,int elsize,int elsign,int ndimslow,int ndimfast\n"
		"\n"
		"C prototype: int cbf_get_image_sf (cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, void *array, size_t elsize,\n"
		"                 int elsign, size_t      ndimslow, size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_image, cbf_get_image_fs and cbf_get_image_sf read the image \n"
		"array for element number element_number into an array. The array \n"
		"consists of ndimslow *ndimfast elements of elsize bytes each, \n"
		"starting at array. The elements are signed if elsign is non-0 and \n"
		"unsigned otherwise. cbf_get_real_image, cbf_get_real_image_fs and \n"
		"cbf_get_real_image_sf read the image array of IEEE doubles or floats \n"
		"for element number element_number into an array. A real array is \n"
		"always signed. cbf_get_3d_image, cbf_get_3d_image_fs and \n"
		"cbf_get_3d_image_sf read the 3D image array for element number \n"
		"element_number into an array. The array consists of ndimslow *ndimmid \n"
		"*ndimfast elements of elsize bytes each, starting at array. The \n"
		"elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_get_real_3d_image, cbf_get_real_3d_image_fs, \n"
		"cbf_get_real_3d_image_sf reads the 3D image array of IEEE doubles or \n"
		"floats for element number element_number into an array. A real array \n"
		"is always signed.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"The structure of the array as a 1-, 2- or 3-dimensional array should \n"
		"agree with the structure of the array given in the \n"
		"ARRAY_STRUCTURE_LIST category. If the array is 1-dimensional, \n"
		"ndimslow should be the array size and ndimfast and, for the 3D calls, \n"
		"ndimmid, should be set to 1 both in the call and in the imgCIF data \n"
		"being processed. If the array is 2-dimensional and a 3D call is used, \n"
		"ndimslow and ndimmid should be the\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_3d_image_size_fs", _wrap_cbf_handle_struct_get_3d_image_size_fs, METH_VARARGS, (char *)"cbf_handle_struct_get_3d_image_size_fs(cbf_handle_struct self, unsigned int element_number)"},
	 { (char *)"cbf_handle_struct_set_value", _wrap_cbf_handle_struct_set_value, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_set_value (cbf_handle handle, const char *value);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_value sets the item at the current column and row to the \n"
		"ASCII value value.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. value    ASCII value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_current_timestamp", _wrap_cbf_handle_struct_set_current_timestamp, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : Integer timezone\n"
		"\n"
		"C prototype: int cbf_set_current_timestamp (cbf_handle handle,\n"
		"                 unsigned int reserved,      int timezone);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_current_timestamp sets the collection timestamp to the \n"
		"current time. The timezone difference from UTC in minutes is set to \n"
		"timezone. If no timezone is desired, timezone should be \n"
		"CBF_NOTIMEZONE. If no timezone is used, the timest amp will be UTC. \n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"The new timestamp will have a precision of 1 second.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. reserved   Unused.   Any value other than 0 is \n"
		"invalid. timezone   Timezone difference from UTC in minutes or \n"
		"CBF_NOTIMEZONE.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_doublevalue", _wrap_cbf_handle_struct_require_doublevalue, METH_VARARGS, (char *)"\n"
		"Returns : Float Number\n"
		"*args   : Float Default\n"
		"\n"
		"C prototype: int cbf_require_doublevalue (cbf_handle handle, double *number,\n"
		"                 double    defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_doublevalue sets *number to the value of the ASCII item at \n"
		"the current column and row interpreted as a decimal floating-point \n"
		"number. cbf_require_doublevalue sets *number to the value of the \n"
		"ASCII item at the current column and row interpreted as a decimal \n"
		"floating-point number, setting it to defaultvalue if necessary.\n"
		"If the value is not ASCII, the function returns CBF_BINARY.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. number         Pointer to the destination \n"
		"number. defaultvalue   default number value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_rewind_datablock", _wrap_cbf_handle_struct_rewind_datablock, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_rewind_datablock (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_rewind_datablock makes the first data block the current data \n"
		"block.\n"
		"If there are no data blocks, the function returns CBF_NOTFOUND.\n"
		"The current category becomes undefined.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_require_column_value", _wrap_cbf_handle_struct_require_column_value, METH_VARARGS, (char *)"\n"
		"Returns : String Name\n"
		"*args   : String columnnanme,String Default\n"
		"\n"
		"C prototype: int cbf_require_column_value (cbf_handle handle,\n"
		"                 const char *columnname,      const char **value,\n"
		"                 const char *defaultvalue);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_require_column_doublevalue sets *value to the ASCII item at the \n"
		"current row for the column given with the name given by *columnname, \n"
		"or to the string given by defaultvalue if the item cannot be found.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. columnname     Name of the column \n"
		"containing the number. value          pointer to the location to \n"
		"receive the value. defaultvalue   Value to use if the requested \n"
		"column and value cannot be found.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_dictionary", _wrap_cbf_handle_struct_get_dictionary, METH_VARARGS, (char *)"\n"
		"Returns : CBFHandle dictionary\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_dictionary (cbf_handle handle,\n"
		"                 cbf_handle * dictionary);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_dictionary sets *dictionary to the handle of a CBF which has \n"
		"been associated with the CBF handle by cbf_set_dictionary. \n"
		"cbf_set_dictionary associates the CBF handle dictionary_in with \n"
		"handle as its dictionary. cbf_require_dictionary sets *dictionary to \n"
		"the handle of a CBF which has been associated with the CBF handle by \n"
		"cbf_set_dictionary or creates a new empty CBF and associates it with \n"
		"handle, returning the new handle in *dictionary.\n"
		"ARGUMENTS\n"
		"handle          CBF handle. dictionary      Pointer to CBF handle of \n"
		"dictionary. dictionary_in   CBF handle of dcitionary.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_reset_saveframe", _wrap_cbf_handle_struct_reset_saveframe, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_reset_saveframe (cbf_handle handle);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_reset_datablock deletes all categories from the current data \n"
		"block. cbf_reset_saveframe deletes all categories from the current \n"
		"save frame.\n"
		"ARGUMENTS\n"
		"handle   CBF handle.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_reciprocal_cell", _wrap_cbf_handle_struct_set_reciprocal_cell, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_set_reciprocal_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_reciprocal_cell sets the reciprocal cell parameters to the \n"
		"double values given in cell[0:2] for the reciprocal cell edge lengths \n"
		"a*, b* and c* in AAngstroms-1, the double values given in cell[3:5] \n"
		"for the reciprocal cell angles a*, b* and g* in degrees, the double \n"
		"values given in cell_esd[0:2] for the estimated strandard deviations \n"
		"of the reciprocal cell edge lengths a*, b* and c* in AAngstroms, and \n"
		"the double values given in cell_esd[3:5] for the estimated standard \n"
		"deviations of the reciprocal cell angles a*, b* and g* in degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the reciprocal cell parameters are not set.\n"
		"If cell_esd is NULL, the reciprocal cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the reciprocal cell parameters. cell_esd   Pointer to the array \n"
		"of 6 doubles for the reciprocal cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_reciprocal_cell_esd", _wrap_cbf_handle_struct_set_reciprocal_cell_esd, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double cell_esd[6]\n"
		"\n"
		"C prototype: int cbf_set_reciprocal_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_reciprocal_cell sets the reciprocal cell parameters to the \n"
		"double values given in cell[0:2] for the reciprocal cell edge lengths \n"
		"a*, b* and c* in AAngstroms-1, the double values given in cell[3:5] \n"
		"for the reciprocal cell angles a*, b* and g* in degrees, the double \n"
		"values given in cell_esd[0:2] for the estimated strandard deviations \n"
		"of the reciprocal cell edge lengths a*, b* and c* in AAngstroms, and \n"
		"the double values given in cell_esd[3:5] for the estimated standard \n"
		"deviations of the reciprocal cell angles a*, b* and g* in degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the reciprocal cell parameters are not set.\n"
		"If cell_esd is NULL, the reciprocal cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the reciprocal cell parameters. cell_esd   Pointer to the array \n"
		"of 6 doubles for the reciprocal cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_real_3d_image_fs", _wrap_cbf_handle_struct_set_real_3d_image_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int dimfast,int dimmid,int dimslow\n"
		"\n"
		"C prototype: int cbf_set_real_3d_image_fs(cbf_handle handle,\n"
		"                 unsigned int reserved,      unsigned int element_number,\n"
		"                 unsigned int compression, void      *array,size_t elsize,\n"
		"                 size_t ndimfast, size_t ndimmid, size_t ndimslow);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_doublevalue", _wrap_cbf_handle_struct_set_doublevalue, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : String format,Float number\n"
		"\n"
		"C prototype: int cbf_set_doublevalue (cbf_handle handle, const char *format,\n"
		"                 double    number);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_doublevalue sets the item at the current column and row to \n"
		"the floating-point value number written as an ASCII string with the \n"
		"format specified by format as appropriate for the printf function.\n"
		"ARGUMENTS\n"
		"handle   CBF handle. format   Format for the number. number   \n"
		"Floating-point value.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_category", _wrap_cbf_handle_struct_find_category, METH_VARARGS, (char *)"\n"
		"Returns : string\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_find_category (cbf_handle handle,\n"
		"                 const char *categoryname);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_category makes the category in the current data block with \n"
		"name categoryname the current category.\n"
		"The comparison is case-insensitive.\n"
		"If the category does not exist, the function returns CBF_NOTFOUND.\n"
		"The current column and row become undefined.\n"
		"ARGUMENTS\n"
		"handle         CBF handle. categoryname   The name of the category to \n"
		"find.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_get_integerarrayparameters_wdims_fs", _wrap_cbf_handle_struct_get_integerarrayparameters_wdims_fs, METH_VARARGS, (char *)"\n"
		"Returns : int compression,int binary_id,int elsize,int elsigned,int elunsigned,\n"
		"          int elements,int minelement,int maxelement,char **bo,int *bolen,\n"
		"          int dimfast,int dimmid,int dimslow,int padding\n"
		"*args   : \n"
		"\n"
		"C prototype: int cbf_get_integerarrayparameters_wdims_fs (cbf_handle handle,\n"
		"                 unsigned    int *compression, int *binary_id, size_t *elsize,\n"
		"                 int *elsigned, int    *elunsigned, size_t *elements,\n"
		"                 int *minelement, int *maxelement, const    char **byteorder,\n"
		"                 size_t *dimfast, size_t *dimmid, size_t *dimslow,\n"
		"                 size_t    *padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_get_integerarrayparameters sets *compression, *binary_id, \n"
		"*elsize, *elsigned, *elunsigned, *elements, *minelement and \n"
		"*maxelement to values read from the binary value of the item at the \n"
		"current column and row. This provides all the arguments needed for a \n"
		"subsequent call to cbf_set_integerarray, if a copy of the array is to \n"
		"be made into another CIF or CBF. cbf_get_realarrayparameters sets \n"
		"*compression, *binary_id, *elsize, *elements to values read from the \n"
		"binary value of the item at the current column and row. This provides \n"
		"all the arguments needed for a subsequent call to cbf_set_realarray, \n"
		"if a copy of the arry is to be made into another CIF or CBF.\n"
		"The variants cbf_get_integerarrayparameters_wdims, \n"
		"cbf_get_integerarrayparameters_wdims_fs, \n"
		"cbf_get_integerarrayparameters_wdims_sf, \n"
		"cbf_get_realarrayparameters_wdims, \n"
		"cbf_get_realarrayparameters_wdims_fs, \n"
		"cbf_get_realarrayparameters_wdims_sf set **byteorder, *dimfast, \n"
		"*dimmid, *dimslow, and *padding as well, providing the additional \n"
		"parameters needed for a subsequent call to cbf_set_integerarray_wdims \n"
		"or cbf_set_realarray_wdims.\n"
		"The value returned in *byteorder is a pointer either to the string  \n"
		"\"little_endian \" or to the string  \"big_endian \". This should be \n"
		"the byte order of the data, not necessarily of the host machine. No \n"
		"attempt should be made to modify this string. At this time only  \n"
		"\"little_endian \" will be returned.\n"
		"The values returned in *dimfast, *dimmid and *dimslow are the sizes \n"
		"of the fastest changing, second fastest changing and third fastest \n"
		"changing dimensions of the array, if specified, or zero, if not \n"
		"specified.\n"
		"The value returned in *padding is the size of the post-data padding, \n"
		"if any and if specified in the data header. The value is given as a \n"
		"count of octets.\n"
		"If the value is not binary, the function returns CBF_ASCII.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method used. \n"
		"elsize        Size in bytes of each array element. binary_id     \n"
		"Pointer to the destination integer binary identifier. elsigned      \n"
		"Pointer to an integer. Set to 1 if the elements can be read as signed \n"
		"integers. elunsigned    Pointer to an integer. Set to 1 if the \n"
		"elements can be read as unsigned integers. elements      Pointer to \n"
		"the destination number of elements. minelement    Pointer to the \n"
		"destination smallest element. maxelement    Pointer to the \n"
		"destination largest element. byteorder     Pointer to the destination \n"
		"byte order. dimfast       Pointer to the destination fastest \n"
		"dimension. dimmid        Pointer to the destination second fastest \n"
		"dimension. dimslow       Pointer to the destination third fastest \n"
		"dimension. padding       Pointer to the destination padding size.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_realarray_wdims_fs", _wrap_cbf_handle_struct_set_realarray_wdims_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimfast,int dimmid,int dimslow,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_realarray_wdims_fs (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, size_t elements,    const char *byteorder,\n"
		"                 size_t dimfast, size_t dimmid, size_t dimslow,\n"
		"                    size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_find_category_root", _wrap_cbf_handle_struct_find_category_root, METH_VARARGS, (char *)"\n"
		"Returns : String categoryroot\n"
		"*args   : String categoryname\n"
		"\n"
		"C prototype: int cbf_find_category_root (cbf_handle handle,\n"
		"                 const char* categoryname,      const char** categoryroot);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_find_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias. cbf_set_category_root sets \n"
		"categoryname_in as an alias of categoryroot in the dictionary \n"
		"associated with handle, creating the dictionary if necessary. \n"
		"cbf_require_category_root sets *categoryroot to the root category of \n"
		"which categoryname is an alias, if there is one, or to the value of \n"
		"categoryname, if categoryname is not an alias.\n"
		"A returned categoryroot string must not be modified in any way.\n"
		"ARGUMENTS\n"
		"handle            CBF handle. categoryname      category name which \n"
		"may be an alias. categoryroot      pointer to a returned category \n"
		"root name. categoryroot_in   input category root name.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_integerarray_wdims_fs", _wrap_cbf_handle_struct_set_integerarray_wdims_fs, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int compression,int binary_id,(binary) String data,int elsize,\n"
		"          int elements,String byteorder,int dimfast,int dimmid,int dimslow,\n"
		"          int padding\n"
		"\n"
		"C prototype: int cbf_set_integerarray_wdims_fs (cbf_handle handle,\n"
		"                 unsigned int    compression, int binary_id, void *array,\n"
		"                 size_t elsize, int elsigned,    size_t elements,\n"
		"                 const char *byteorder, size_t dimfast, size_t dimmid,\n"
		"                    size_t dimslow, size_t padding);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_integerarray sets the binary value of the item at the current \n"
		"column and row to an integer array. The array consists of elements \n"
		"elements of elsize bytes each, starting at array. The elements are \n"
		"signed if elsigned is non-0 and unsigned otherwise. binary_id is the \n"
		"binary section identifier. cbf_set_realarray sets the binary value of \n"
		"the item at the current column and row to an integer array. The array \n"
		"consists of elements elements of elsize bytes each, starting at \n"
		"array. binary_id is the binary section identifier.\n"
		"The cbf_set_integerarray_wdims, cbf_set_integerarray_wdims_fs, \n"
		"cbf_set_integerarray_wdims_sf, cbf_set_realarray_wdims, \n"
		"cbf_set_realarray_wdims_fs and cbf_set_realarray_wdims_sf variants \n"
		"allow the data header values of byteorder, dimfast, dimmid, dimslow \n"
		"and padding to be set to the data byte order, the fastest, second \n"
		"fastest and third fastest array dimensions and the size in byte of \n"
		"the post data padding to be used.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL     Canonical-code compression (section 3.3.1) \n"
		"CBF_PACKED        CCP4-style packing (section 3.3.2) CBF_PACKED_V2    \n"
		" CCP4-style packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   \n"
		"Simple  \"byte_offset \" compression. CBF_NONE          No \n"
		"compression. NOTE: This scheme is by far the slowest of the four and \n"
		"uses much more disk space. It is intended for routine use with small \n"
		"arrays only. With large arrays (like images) it should be used only \n"
		"for debugging.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned), for cbf_set_integerarray, or IEEE doubles or \n"
		"floats for cbf_set_realarray. If elsize is not equal to sizeof \n"
		"(char), sizeof (short) or sizeof (int), the function returns \n"
		"CBF_ARGUMENT.\n"
		"ARGUMENTS\n"
		"handle        CBF handle. compression   Compression method to use. \n"
		"binary_id     Integer binary identifier. array         Pointer to the \n"
		"source array. elsize        Size in bytes of each source array \n"
		"element. elsigned      Set to non-0 if the source array elements are \n"
		"signed. elements: The number of elements in the array.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_image_sf", _wrap_cbf_handle_struct_set_image_sf, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : int element_number,int compression,(binary) String data,int elsize,\n"
		"          int elsign,int dimslow,int dimfast\n"
		"\n"
		"C prototype: int cbf_set_image_sf(cbf_handle handle, unsigned int reserved,\n"
		"                 unsigned      int element_number, unsigned int compression,\n"
		"                 void *array, size_t      elsize, int elsign, size_t ndimslow,\n"
		"                 size_t ndimfast);\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_image, cbf_set_image_fs and cbf_set_image_sf write the image \n"
		"array for element number element_number. The array consists of \n"
		"ndimfast *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-zero and unsigned otherwise. \n"
		"cbf_set_real_image, cbf_set_real_image_fs and cbf_set_real_image_sf \n"
		"write the image array for element number element_number. The array \n"
		"consists of ndimfast *ndimslow IEEE double or float elements of \n"
		"elsize bytes each, starting at array. cbf_set_3d_image, \n"
		"cbf_set_3d_image_fs and cbf_set_3d_image_sf write the 3D image array \n"
		"for element number element_number. The array consists of ndimfast \n"
		"*ndimmid *ndimslow elements of elsize bytes each, starting at array. \n"
		"The elements are signed if elsign is non-0 and unsigned otherwise. \n"
		"cbf_set_real_3d_image, cbf_set_real_3d_image_fs and \n"
		"cbf_set_real_3d_image_sf writes the 3D image array for element number \n"
		"element_number. The array consists of ndimfast *ndimmid *ndimslow \n"
		"IEEE double or float elements of elsize bytes each, starting at \n"
		"array.\n"
		"The _fs calls give the dimensions in a fast-to-slow order. The calls \n"
		"with no suffix and the calls _sf calls give the dimensions in \n"
		"slow-to-fast order\n"
		"If the array is 1-dimensional, ndimslow should be the array size and \n"
		"ndimfast and, for the 3D calls, ndimmid, should be set to 1. If the \n"
		"array is 2-dimensional and the 3D calls are used, ndimslow and \n"
		"ndimmid should be used for the array dimensions and ndimfast should \n"
		"be set to 1.\n"
		"The array will be compressed using the compression scheme specifed by \n"
		"compression. Currently, the available schemes are:\n"
		"CBF_CANONICAL   Canonical-code compression (section 3.3.1) CBF_PACKED \n"
		"     CCP4-style packing (section 3.3.2) CBF_PACKED_V2     CCP4-style \n"
		"packing, version 2 (section 3.3.2) CBF_BYTE_OFFSET   Simple  \n"
		"\"byte_offset \" compression. CBF_NONE        No compression.\n"
		"The values compressed are limited to 64 bits. If any element in the \n"
		"array is larger than 64 bits, the value compressed is the nearest \n"
		"64-bit value.\n"
		"Currently, the source array must consist of chars, shorts or ints \n"
		"(signed or unsigned)for cbf_set_image, or IEEE doubles or floats for \n"
		"cbf_set_real_image. If elsize is not equal to sizeof (short), sizeof \n"
		"(int), sizeof(double) or sizeof(float), the function returns \n"
		"CBF_ARGUMENT.\n"
		"The parameter reserved is presently unused and should be set to 0.\n"
		"ARGUMENTS\n"
		"handle           CBF handle. reserved         Unused. Any value other \n"
		"than 0 is invalid. element_number   The number of the detector \n"
		"element counting from 0 by order of appearance in the  \n"
		"\"diffrn_data_frame \" category. compression      Compression type. \n"
		"array            Pointer to the image array. elsize           Size in \n"
		"bytes of each image array element. elsigned         Set to non-0 if \n"
		"the image array elements are signed. ndimslow         Slowest array \n"
		"dimension. ndimmid          Second slowest array dimension. ndimfast  \n"
		"       Fastest array dimension.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"----------------------------------------------------------------------\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_unit_cell", _wrap_cbf_handle_struct_set_unit_cell, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double cell[6]\n"
		"\n"
		"C prototype: int cbf_set_unit_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_unit_cell sets the cell parameters to the double values given \n"
		"in cell[0:2] for the cell edge lengths a, b and c in AAngstroms, the \n"
		"double values given in cell[3:5] for the cell angles a, b and g in \n"
		"degrees, the double values given in cell_esd[0:2] for the estimated \n"
		"strandard deviations of the cell edge lengths a, b and c in \n"
		"AAngstroms, and the double values given in cell_esd[3:5] for the \n"
		"estimated standard deviations of the the cell angles a, b and g in \n"
		"degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the cell parameters are not set.\n"
		"If cell_esd is NULL, the cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the cell parameters. cell_esd   Pointer to the array of 6 doubles \n"
		"for the cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_set_unit_cell_esd", _wrap_cbf_handle_struct_set_unit_cell_esd, METH_VARARGS, (char *)"\n"
		"Returns : \n"
		"*args   : double cell_esd[6]\n"
		"\n"
		"C prototype: int cbf_set_unit_cell (cbf_handle handle, double cell[6],\n"
		"                 double      cell_esd[6] );\n"
		"\n"
		"CBFLib documentation:\n"
		"DESCRIPTION\n"
		"cbf_set_unit_cell sets the cell parameters to the double values given \n"
		"in cell[0:2] for the cell edge lengths a, b and c in AAngstroms, the \n"
		"double values given in cell[3:5] for the cell angles a, b and g in \n"
		"degrees, the double values given in cell_esd[0:2] for the estimated \n"
		"strandard deviations of the cell edge lengths a, b and c in \n"
		"AAngstroms, and the double values given in cell_esd[3:5] for the \n"
		"estimated standard deviations of the the cell angles a, b and g in \n"
		"degrees.\n"
		"The values are placed in the first row of the  \"cell \" category. If \n"
		"no value has been given for  \"_cell.entry_id \", it is set to the \n"
		"value of the  \"diffrn.id \" entry of the current data block.\n"
		"cell or cell_esd may be NULL.\n"
		"If cell is NULL, the cell parameters are not set.\n"
		"If cell_esd is NULL, the cell parameter esds are not set.\n"
		"If the  \"cell \" category is not present, it is created. If any of \n"
		"the necessary columns are not present, they are created.\n"
		"ARGUMENTS\n"
		"handle     CBF handle. cell       Pointer to the array of 6 doubles \n"
		"for the cell parameters. cell_esd   Pointer to the array of 6 doubles \n"
		"for the cell parameter esds.\n"
		"RETURN VALUE\n"
		"Returns an error code on failure or 0 for success.\n"
		"SEE ALSO\n"
		"\n"
		""},
	 { (char *)"cbf_handle_struct_swigregister", cbf_handle_struct_swigregister, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_shortArrayTo_p_short(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((short *)  ((shortArray *) x));
}
static void *_p_longArrayTo_p_long(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((long *)  ((longArray *) x));
}
static void *_p_intArrayTo_p_int(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((int *)  ((intArray *) x));
}
static void *_p_a_4__doubleArrayTo_p_a_4__double(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((double (*)[4])  ((doubleArray (*)[4]) x));
}
static void *_p_doubleArrayTo_p_double(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((double *)  ((doubleArray *) x));
}
static swig_type_info _swigt__p_CBF_NODETYPE = {"_p_CBF_NODETYPE", "enum CBF_NODETYPE *|CBF_NODETYPE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__double = {"_p_a_4__double", "double (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__doubleArray = {"_p_a_4__doubleArray", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_cbf_axis_struct = {"_p_cbf_axis_struct", "cbf_axis_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_detector_struct = {"_p_cbf_detector_struct", "cbf_detector|cbf_detector_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_handle_struct = {"_p_cbf_handle_struct", "cbf_handle|cbf_handle_struct *|handle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_node = {"_p_cbf_node", "cbf_node *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_positioner = {"_p_cbf_positioner", "cbf_positioner *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cbf_positioner_struct = {"_p_cbf_positioner_struct", "cbf_goniometer|cbf_positioner_struct *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_doubleArray = {"_p_doubleArray", "struct doubleArray *|doubleArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_intArray = {"_p_intArray", "struct intArray *|intArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_longArray = {"_p_longArray", "struct longArray *|longArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_shortArray = {"_p_shortArray", "struct shortArray *|shortArray *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_CBF_NODETYPE,
  &_swigt__p_a_4__double,
  &_swigt__p_a_4__doubleArray,
  &_swigt__p_cbf_axis_struct,
  &_swigt__p_cbf_detector_struct,
  &_swigt__p_cbf_handle_struct,
  &_swigt__p_cbf_node,
  &_swigt__p_cbf_positioner,
  &_swigt__p_cbf_positioner_struct,
  &_swigt__p_char,
  &_swigt__p_double,
  &_swigt__p_doubleArray,
  &_swigt__p_int,
  &_swigt__p_intArray,
  &_swigt__p_long,
  &_swigt__p_longArray,
  &_swigt__p_p_char,
  &_swigt__p_short,
  &_swigt__p_shortArray,
  &_swigt__p_size_t,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_CBF_NODETYPE[] = {  {&_swigt__p_CBF_NODETYPE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__doubleArray[] = {{&_swigt__p_a_4__doubleArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__double[] = {  {&_swigt__p_a_4__doubleArray, _p_a_4__doubleArrayTo_p_a_4__double, 0, 0},  {&_swigt__p_a_4__double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_axis_struct[] = {  {&_swigt__p_cbf_axis_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_detector_struct[] = {  {&_swigt__p_cbf_detector_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_handle_struct[] = {  {&_swigt__p_cbf_handle_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_node[] = {  {&_swigt__p_cbf_node, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_positioner[] = {  {&_swigt__p_cbf_positioner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cbf_positioner_struct[] = {  {&_swigt__p_cbf_positioner_struct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_doubleArray, _p_doubleArrayTo_p_double, 0, 0},  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_doubleArray[] = {  {&_swigt__p_doubleArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_intArray, _p_intArrayTo_p_int, 0, 0},  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_intArray[] = {  {&_swigt__p_intArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},  {&_swigt__p_longArray, _p_longArrayTo_p_long, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_longArray[] = {  {&_swigt__p_longArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_shortArray, _p_shortArrayTo_p_short, 0, 0},  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_shortArray[] = {  {&_swigt__p_shortArray, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_CBF_NODETYPE,
  _swigc__p_a_4__double,
  _swigc__p_a_4__doubleArray,
  _swigc__p_cbf_axis_struct,
  _swigc__p_cbf_detector_struct,
  _swigc__p_cbf_handle_struct,
  _swigc__p_cbf_node,
  _swigc__p_cbf_positioner,
  _swigc__p_cbf_positioner_struct,
  _swigc__p_char,
  _swigc__p_double,
  _swigc__p_doubleArray,
  _swigc__p_int,
  _swigc__p_intArray,
  _swigc__p_long,
  _swigc__p_longArray,
  _swigc__p_p_char,
  _swigc__p_short,
  _swigc__p_shortArray,
  _swigc__p_size_t,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;
  
  clientdata = clientdata;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpeters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;  
    if (!type_init) {
      const PyTypeObject tmp
      = {
        /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* Number of items in variable part (ob_size) */
#endif
        (char *)"swigvarlink",              /* Type name (tp_name) */
        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
        0,                                  /* Itemsize (tp_itemsize) */
        (destructor) swig_varlink_dealloc,  /* Deallocator (tp_dealloc) */ 
        (printfunc) swig_varlink_print,     /* Print (tp_print) */
        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
        0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
      varlink_type = tmp;
      /* for Python 3 we already assigned ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
      varlink_type.ob_type = &PyType_Type;
#endif
      type_init = 1;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (c && (c = strstr(c, "swig_ptr: "))) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          size_t shift = (ci->ptype) - types;
          swig_type_info *ty = types_initial[shift];
          size_t ldoc = (c - methods[i].ml_doc);
          size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
          char *ndoc = (char*)malloc(ldoc + lptr + 10);
          if (ndoc) {
            char *buff = ndoc;
            void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
            if (ptr) {
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d;  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  d = PyModule_GetDict(m);
  
  SWIG_InitializeModule(0);
  SWIG_InstallConstants(d,swig_const_table);
  
  
  SWIG_Python_SetConstant(d, "CBF_INTEGER",SWIG_From_int((int)(0x0010)));
  SWIG_Python_SetConstant(d, "CBF_FLOAT",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "CBF_CANONICAL",SWIG_From_int((int)(0x0050)));
  SWIG_Python_SetConstant(d, "CBF_PACKED",SWIG_From_int((int)(0x0060)));
  SWIG_Python_SetConstant(d, "CBF_PACKED_V2",SWIG_From_int((int)(0x0090)));
  SWIG_Python_SetConstant(d, "CBF_BYTE_OFFSET",SWIG_From_int((int)(0x0070)));
  SWIG_Python_SetConstant(d, "CBF_PREDICTOR",SWIG_From_int((int)(0x0080)));
  SWIG_Python_SetConstant(d, "CBF_NONE",SWIG_From_int((int)(0x0040)));
  SWIG_Python_SetConstant(d, "CBF_COMPRESSION_MASK",SWIG_From_int((int)(0x00FF)));
  SWIG_Python_SetConstant(d, "CBF_FLAG_MASK",SWIG_From_int((int)(0x0F00)));
  SWIG_Python_SetConstant(d, "CBF_UNCORRELATED_SECTIONS",SWIG_From_int((int)(0x0100)));
  SWIG_Python_SetConstant(d, "CBF_FLAT_IMAGE",SWIG_From_int((int)(0x0200)));
  SWIG_Python_SetConstant(d, "CBF_NO_EXPAND",SWIG_From_int((int)(0x0400)));
  SWIG_Python_SetConstant(d, "PLAIN_HEADERS",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "MIME_HEADERS",SWIG_From_int((int)(0x0002)));
  SWIG_Python_SetConstant(d, "MSG_NODIGEST",SWIG_From_int((int)(0x0004)));
  SWIG_Python_SetConstant(d, "MSG_DIGEST",SWIG_From_int((int)(0x0008)));
  SWIG_Python_SetConstant(d, "MSG_DIGESTNOW",SWIG_From_int((int)(0x0010)));
  SWIG_Python_SetConstant(d, "MSG_DIGESTWARN",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "PAD_1K",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "PAD_2K",SWIG_From_int((int)(0x0040)));
  SWIG_Python_SetConstant(d, "PAD_4K",SWIG_From_int((int)(0x0080)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_BRC",SWIG_From_int((int)(0x0100)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_PRN",SWIG_From_int((int)(0x0200)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_BKT",SWIG_From_int((int)(0x0400)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_BRACKETS",SWIG_From_int((int)(0x0700)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_TQ",SWIG_From_int((int)(0x0800)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_CIF2_DELIMS",SWIG_From_int((int)(0x1000)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_DDLm",SWIG_From_int((int)(0x0700)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_CIF2",SWIG_From_int((int)(0x1F00)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_DEFINES",SWIG_From_int((int)(0x2000)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_WIDE",SWIG_From_int((int)(0x4000)));
  SWIG_Python_SetConstant(d, "CBF_PARSE_UTF8",SWIG_From_int((int)(0x10000)));
  SWIG_Python_SetConstant(d, "HDR_DEFAULT",SWIG_From_int((int)((0x0002|0x0004))));
  SWIG_Python_SetConstant(d, "MIME_NOHEADERS",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "CBF",SWIG_From_int((int)(0x0000)));
  SWIG_Python_SetConstant(d, "CIF",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "ENC_NONE",SWIG_From_int((int)(0x0001)));
  SWIG_Python_SetConstant(d, "ENC_BASE64",SWIG_From_int((int)(0x0002)));
  SWIG_Python_SetConstant(d, "ENC_BASE32K",SWIG_From_int((int)(0x0004)));
  SWIG_Python_SetConstant(d, "ENC_QP",SWIG_From_int((int)(0x0008)));
  SWIG_Python_SetConstant(d, "ENC_BASE10",SWIG_From_int((int)(0x0010)));
  SWIG_Python_SetConstant(d, "ENC_BASE16",SWIG_From_int((int)(0x0020)));
  SWIG_Python_SetConstant(d, "ENC_BASE8",SWIG_From_int((int)(0x0040)));
  SWIG_Python_SetConstant(d, "ENC_FORWARD",SWIG_From_int((int)(0x0080)));
  SWIG_Python_SetConstant(d, "ENC_BACKWARD",SWIG_From_int((int)(0x0100)));
  SWIG_Python_SetConstant(d, "ENC_CRTERM",SWIG_From_int((int)(0x0200)));
  SWIG_Python_SetConstant(d, "ENC_LFTERM",SWIG_From_int((int)(0x0400)));
  SWIG_Python_SetConstant(d, "ENC_DEFAULT",SWIG_From_int((int)((0x0002|0x0400|0x0080))));
  SWIG_Python_SetConstant(d, "CBF_UNDEFNODE",SWIG_From_int((int)(CBF_UNDEFNODE)));
  SWIG_Python_SetConstant(d, "CBF_LINK",SWIG_From_int((int)(CBF_LINK)));
  SWIG_Python_SetConstant(d, "CBF_ROOT",SWIG_From_int((int)(CBF_ROOT)));
  SWIG_Python_SetConstant(d, "CBF_DATABLOCK",SWIG_From_int((int)(CBF_DATABLOCK)));
  SWIG_Python_SetConstant(d, "CBF_SAVEFRAME",SWIG_From_int((int)(CBF_SAVEFRAME)));
  SWIG_Python_SetConstant(d, "CBF_CATEGORY",SWIG_From_int((int)(CBF_CATEGORY)));
  SWIG_Python_SetConstant(d, "CBF_COLUMN",SWIG_From_int((int)(CBF_COLUMN)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

